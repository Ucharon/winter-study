# 寒假学习打卡



## 1.2

### 复习题目：

#### 2. 两数相加-中等(模拟法)

**模拟法解决**

代码：

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //使用带头节点的单链表来存储答案
        ListNode head = new ListNode();
        ListNode p = head;
        
        int carry = 0;
        //当l1和l2都为null的时候退出循环
        while (!(l1 == null && l2 == null)) {
            //将两个链表中的值都给取出来
            int a = l1 != null ? l1.val : 0;
            int b = l2 != null ? l2.val : 0;
            //相加
            int sum = a + b + carry;
            //求出下一位，以及进位
            carry = sum / 10;
            sum = sum % 10;
            //新建结点
            ListNode t = new ListNode(sum);
            p.next = t;
            p = p.next;

            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
    
        //加上最后一位
        if (carry == 1) {
            p.next = new ListNode(1);
        }    

        return head.next;
    }
}
```



#### 3. 无重复字符的最长子串-中等(滑动窗口)

**滑动窗口解决**

什么是滑动窗口？

其实就是一个队列,比如例题中的 `abcabcbb`，进入这个队列（窗口）为 `abc` 满足题目要求，当再进入 `a`，队列变成了 `abca`，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

时间复杂度：O(n)

代码：

```java
class Solution {
    /**
        滑动窗口解决
     */
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        //分别记录最长窗口和当前窗口的左边界
        int max, left;
        max = left = 0;
        //记录已遍历的字符及其所在的下标
        Map<Character, Integer> map = new HashMap<>();
        
        //开始遍历
        for (int i = 0; i < s.length(); i++) {
            //如果该字母已经在哈希表中
            if (map.containsKey(s.charAt(i))) {
                //将左边界移动到该该字母的下标+1的位置，这里防止左边界回移，取left与其比较
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i - left + 1);
        }

        return max;
    }
}
```

### 新题：

#### 4. 寻找两个正序数组的中位数-困难(二分法)

**二分法解决-等价寻找第k大的数**

代码：

```java
class Solution {
    /**
        二分法解决
    
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n, m, left, right;
        n = nums1.length;
        m = nums2.length;
        left = (n + m + 1) / 2;
        right = (n + m + 2) / 2;
        return (
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) +
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)
            ) * 0.5;
    }

    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让len1的长度小于len2，这样就能保证如果有数组空了，一定是len1 
        if (len1 > len2) {
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        //如果len1为空，退出递归
        if (len1 == 0) {
            return nums2[start2 + k - 1];
        }
        //k为1
        if (k == 1) {
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(k / 2, len1) - 1;
        int j = start2 + Math.min(k / 2, len2) - 1;
        if (nums1[i] < nums2[j]) {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        } else {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
    }
}
```

#### 15. 三数之和-中等(线性枚举+二分法)

**采用线性枚举+二分法解**

该题可以转化为nums[i] + nums[j] = -nums[k]

代码：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // 该题可以转化为nums[i] + nums[j] = -nums[k]
        // 采用线性枚举+二分法解
        List<List<Integer>> res = new ArrayList<>();
        int n = nums.length;
        //先对nums进行排序
        Arrays.sort(nums);
        for (int k = 0; k < n; k++) {
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            if (nums[k] > 0) {
                break;
            }

            int i = k + 1, j = n - 1;
            while (i < j) {
                if (nums[i] + nums[j] > -nums[k]) {
                    j--;
                } else if (nums[i] + nums[j] < -nums[k]) {
                    i++;
                } else {
                    res.add(new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[k])));
                    j--;
                    i++;
                    //可能会出现连续重复的数
                    while (i < j && nums[i] == nums[i + 1]) i++;
                    while (i < j && nums[j] == nums[j - 1]) j--;
                }
            }
        }

        return res;
    }
}
```





## 1.3

今天的目标是学习巩固动态规划！

### 复习题目：

#### 5. 最长回文子串-中等(动态规划)

**经典的动态规划题**

定义状态`dp[i][j]`为i到j是否为回文串

初始化状态：每个大小为1的子串都是回文串

状态转移方程为：

​	如果`s[i] == s[j]`，且`dp[i + 1][j - 1] == 1`，则`dp[i][j] = 1`，这里有特殊情况，如果该子串大小小与等于3时候，则直接为1

​	如果`s[i] != s[j]`，则`dp[i][j] = 0`

代码：

```java
class Solution {
    /**
    动态规划求解
     */
    public String longestPalindrome(String s) {
        //定义状态
        int n = s.length();
        int[][] dp = new int[n][n];
        //初始化状态
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        int left = 0;
        int maxLen = 1;
        //状态转移
        //枚举子串长度
        for (int l = 2; l <= n; l++) {
            //遍历字符串
            for (int i = 0; i < n; i++) {
                //确定右边界
                int j = i + l - 1;
                //右边界越界情况
                if (j >= n) {
                    break;
                }

                if (s.charAt(i) != s.charAt(j)) {
                    dp[i][j] = 0;
                } else {
                    if (j - i <= 2) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                //如果当前dp[i][j]为1，且长度大于目前最大长度，则记录当前长度以及下标
                if (dp[i][j] == 1 && l > maxLen) {
                    maxLen = l;
                    left = i;
                }
            }
        }
        return s.substring(left, left + maxLen);
    }
}
```

#### 198. 打家劫舍-中等(动态规划)

**经典动态规划题**

- 定义状态，`dp[i]`表示已i为结尾能打劫到最大的钱的大小

- 初始化状态，`dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`

- 写出状态转移方程，`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int rob(int[] nums) {
        int n = nums.length;
        //定义状态
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        if (n == 1) {
            return dp[0];   
        }
        dp[1] = Math.max(nums[0], nums[1]);

        //状态转移方程
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
```







### 新题：

#### 10. 正则表达式匹配-困难(动态规划)

**二维动态规划**

1. 定义状态

    `dp[i][j]`表示当字符串长度分别为i、j时，s与p是否匹配

2. 写出状态转移方程

    1. 当`p[j] = '.'或s[i]`时，`dp[i][j] = dp[i - 1][j - 1]`
    2. 当`p[j] = '*'`时
        1. `p[j - 1] != s[i]`，表示不匹配时候，`dp[i][j] = dp[i][j - 2]`
        2. `p[j - 1] != s[i]`，表示匹配的时候，接下来分**3种情况**讨论
            1. 当`*`匹配0个，`dp[i][j] = dp[i][j - 2]`
            2. 当`*`匹配1个，`dp[i][j] = dp[i][j - 1]`
            3. 当`*`匹配2个或更多，`dp[i][j] = dp[i - 1][j]`

代码如下：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        //空字符串处理
        if (s == null || p == null) {
            return true;
        }

        int n, m;
        n = s.length();
        m = p.length();
        //定义状态
        boolean[][] dp = new boolean[n + 1][m + 1];
        //初始化状态
        dp[0][0] = true;
        for (int i = 2; i <= m; i++) {
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = dp[0][i - 2];
            }
        }

        //状态转移
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                //当j不为*
                if (p.charAt(j - 1) != '*') {
                    if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    //第j-1个字符不匹配
                    if (p.charAt(j - 2) != s.charAt(i - 1) && p.charAt(j - 2) != '.') {
                        dp[i][j] = dp[i][j - 2];
                    } else {
                        dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j];
                    }
                }
            }
        }

        return dp[n][m];
    }
  
}
```

#### 19. 删除链表的倒数第 N 个结点-中等(双指针)

**双指针解决问题**

代码：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode quick, slow;
        //先定义一个指针，让他移动n次
        quick = head;
        for (int i = 0; i < n; i++) {
            quick = quick.next;
        }
        if (quick == null) {
            //说明删除的是头节点
            return head.next;
        }
        //再定义慢指针，该指针从head出发
        slow = head;
        while (quick.next != null) {
            slow = slow.next;
            quick = quick.next;
        }
        //删除slow的下一个结点
        slow.next = slow.next.next;

        return head;
    }
}
```

#### 740. 删除并获得点数-中等(动态规划)

这题也是动态规划，和上面的打家劫舍有异曲同工之妙

代码：

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = 0;
        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }
        int[] sum = new int[maxVal + 1];
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }

    public int rob(int[] nums) {
        int size = nums.length;
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```





## 1.4

今天也学几个动态规划题目，顺便预热下回溯算法

### 复习题目：

#### 53. 最大子数组和-中等(动态规划)

直接看代码，**简单动态规划题**

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        //定义状态
        //dp[i]表示以i为结尾的子数组的最大和
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        int res = dp[0];

        //状态转移
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); 
            if (res < dp[i]) {
                res = dp[i];
            }
        }

        return res;
    }
}
```



#### 46. 全排列-中等(回溯)

回溯算法的套路：[回溯算法套路详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93530380?utm_campaign=&utm_medium=social&utm_oi=963759403787276288&utm_psn=1594052365698420736&utm_source=qq)

##### 回溯算法的框架：

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

代码：

```java
class Solution {
    /**
    符合回溯算法框架
     */

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        dfs(res, nums, new ArrayList<>());
        return res;
    }

    public void dfs(List<List<Integer>> res, int[] nums, List<Integer> track) {
        //递归出口
        int n = nums.length;
        if (track.size() == n) {
            res.add(new ArrayList(track));
            return;
        }

        for (int i = 0; i < n; i++) {
            //排除不合法情况
            if (track.contains(nums[i])) {
                continue;
            }
            //做选择
            track.add(nums[i]);
            //进入下一层决策树
            dfs(res, nums, track);
            //撤销选择
            track.remove(track.size() - 1);
        }

    }
}
```

![截屏2023-01-04 19.29.58](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2019.29.58.png)

### 新题：

#### 322. 零钱兑换-中等(动态规划)

**动态规划题**

1. 定义状态

    `dp[i]`表示凑出i块钱最少需要多少硬币

2. 写出状态转移方程

    对于`coin[j]`这个硬币，这里有两种情况

    - 选取该硬币

        `dp[i] = dp[i-coins[j] ] + 1`，不过这里还需要注意，在选的时候，还得考虑 `coins[j]` 是否比 i 大，如果比 i 大的话，显然是不能选的。

    - 不选取该硬币

        `dp[i] = dp[i]`

3. 初始值就比较简单了，当 i = 0 时，显然有 dp[0] = 0。

    不过这里需要注意的是，我们还需要给所有 dp[i] 都赋予一个初始值，否则在递推公式 dp[i] = min(dp[i], dp[i – coins[j]] + 1) 的过程中，dp[i] 有可能会被初始值覆盖，所以我们得给 dp[i] 赋上一个**尽量大**的初始值，可以赋值为 amout + 1。

    详情看代码吧，有些细节需要在代码，才更好说明

代码：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //定义状态
        //dp[i]表示凑出i块钱最少需要多少硬币
        int[] dp = new int[amount + 1];
        //初始化状态 
        // 这里我们还得给dp[i]赋予一个尽量大的初始值
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        //写出状态转移方程
        for (int i = 1; i <= amount; i++) {
            //计算dp[i]所需最少硬币的数量
            for (int j = 0; j < coins.length; j++) {
                //总金额一定大于硬币大小
                if (i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

![截屏2023-01-04 18.29.13](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2018.29.13.png)



#### 20. 有效的括号-简单(栈)

**考察栈的概念**

代码：

```java
class Solution {
    /**
    考察栈的基本概念--先进后出
     */
    public boolean isValid(String s) {
        //新建一个哈希表
        Map<Character, Character> map = new HashMap<>(){{
            put('(', ')'); 
            put('{', '}');
            put('[', ']');
            put('?', '?');
        }};

        if(s.length() > 0 && !map.containsKey(s.charAt(0))) {
            return false;
        }

        LinkedList<Character> stack = new LinkedList<Character>() {{
             add('?');
        }};

        for(Character c : s.toCharArray()){
            if(map.containsKey(c)) { 
                stack.addLast(c);
            } else if(map.get(stack.removeLast()) != c) {
                return false;
            }
        }
        return stack.size() == 1;
    }
}
```

![截屏2023-01-04 18.46.49](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2018.46.49.png)

#### 22. 括号生成-中等(回溯)

**经典回溯算法**

代码：

```java
class Solution {
    /**
    回溯解法
     */
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        dfs(n, res, 0, 0, "");
        return res;
    }

    public void dfs(int n, List<String> res, int left, int right, String str) {
        //递归出口
        if (left < right) {
            return;
        }
        if (left == right && right == n) {
            res.add(str);
            return;
        }

        if (left < n) {
            //加左括号
            dfs(n, res, left + 1, right, str + "(");
        }
        if (right < left) {
            //加右括号
            dfs(n, res, left, right + 1, str + ")");
        }
    }
}
```

![截屏2023-01-04 19.14.07](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2019.14.07.png)





## 1.5(回溯专题)

**今天的主要目标是强化回溯算法**

解决所有**排列组合子集**题目

### 元素无重不可复选-回溯

#### 78. 子集-中等

以下为转载内容

**作者：labuladong**
**链接：https://zhuanlan.zhihu.com/p/474532978**
**来源：知乎**
**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**

题目给你输入一个无重复元素的数组 `nums`，其中每个元素最多使用一次，请你返回 `nums` 的所有子集。

函数签名如下：

```java
List<List<Integer>> subsets(int[] nums)
```

比如输入 `nums = [1,2,3]`，算法应该返回如下子集：

```java
[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]
```

好，我们暂时不考虑如何用代码实现，先回忆一下我们的高中知识，如何手推所有子集？

首先，生成元素个数为 0 的子集，即空集 `[]`，为了方便表示，我称之为 `S_0`。

然后，在 `S_0` 的基础上生成元素个数为 1 的所有子集，我称为 `S_1`：



![img](https://pic3.zhimg.com/v2-35a0e5200b2002e31770bb21d006a062_b.jpg)



接下来，我们可以在 `S_1` 的基础上推导出 `S_2`，即元素个数为 2 的所有子集：



![img](https://pic3.zhimg.com/v2-e2cfa9ecc7df1750c43c1eda73cea862_b.jpg)



为什么集合 `[2]` 只需要添加 `3`，而不添加前面的 `1` 呢？

因为集合中的元素不用考虑顺序， `[1,2,3]` 中 `2` 后面只有 `3`，如果你向前考虑 `1`，那么 `[2,1]` 会和之前已经生成的子集 `[1,2]` 重复。

**换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集**。

接着，我们可以通过 `S_2` 推出 `S_3`，实际上 `S_3` 中只有一个集合 `[1,2,3]`，它是通过 `[1,2]` 推出的。

整个推导过程就是这样一棵树：



![img](https://pic4.zhimg.com/v2-1157a7e0f73d524a5da6a345742f3903_b.jpg)



注意这棵树的特性：

**如果把根节点作为第 0 层，将每个节点和根节点之间树枝上的元素作为该节点的值，那么第 `n` 层的所有节点就是大小为 `n` 的所有子集**。

你比如大小为 2 的子集就是这一层节点的值：



![img](https://pic3.zhimg.com/v2-f04e55d12ad57a0a4afcd9e7d35544de_b.jpg)



> **PS：注意，本文之后所说「节点的值」都是指节点和根节点之间树枝上的元素，且将根节点认为是第 0 层**。

那么再进一步，如果想计算所有子集，那只要遍历这棵多叉树，把所有节点的值收集起来不就行了？

代码：

```java
import java.util.ArrayList;
import java.util.List;

/*
 * @lc app=leetcode.cn id=78 lang=java
 *
 * [78] 子集
 */

// @lc code=start
class Solution {

    public List<List<Integer>> subsets(int[] nums) {
        // 结果集
        List<List<Integer>> res = new ArrayList<>();
        // 存放路径
        List<Integer> track = new ArrayList<>();
        backtrack(res, track, nums, 0);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int[] nums, int start) {

        // 每个节点都是一个结果集
        res.add(new ArrayList<>(track));

        // 回溯算法的基本框架
        for (int i = start; i < nums.length; i++) {
            // 做选择
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(res, track, nums, i + 1);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
// @lc code=end
```

看过前文 [回溯算法核心框架](https://link.zhihu.com/?target=https%3A//labuladong.gitee.io/plugin-v3/%3Fqno%3D51) 的读者应该很容易理解这段代码把，我们使用 `start` 参数控制树枝的生长避免产生重复的子集，用 `track` 记录根节点到每个节点的路径的值，同时在前序位置把每个节点的路径值收集起来，完成回溯树的遍历就收集了所有子集：



![img](https://pic4.zhimg.com/v2-1157a7e0f73d524a5da6a345742f3903_b.jpg)



最后，`backtrack` 函数开头看似没有 base case，会不会进入无限递归？

其实不会的，当 `start == nums.length` 时，叶子节点的值会被装入 `res`，但 for 循环不会执行，也就结束了递归。



#### 77. 组合-中等

**作者：labuladong**
**链接：https://zhuanlan.zhihu.com/p/474532978**
**来源：知乎**
**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**

如果你能够成功的生成所有无重子集，那么你稍微改改代码就能生成所有无重组合了。

你比如说，让你在 `nums = [1,2,3]` 中拿 2 个元素形成所有的组合，你怎么做？

稍微想想就会发现，大小为 2 的所有组合，不就是所有大小为 2 的子集嘛。

**所以我说组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。

比如力扣第 77 题「组合」：

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

函数签名如下：

```java
List<List<Integer>> combine(int n, int k)
```

比如 `combine(3, 2)` 的返回值应该是：

```text
[ [1,2],[1,3],[2,3] ]
```

这是标准的组合问题，但我给你翻译一下就变成子集问题了：

**给你输入一个数组 `nums = [1,2..,n]` 和一个正整数 `k`，请你生成所有大小为 `k` 的子集**。

还是以 `nums = [1,2,3]` 为例，刚才让你求所有子集，就是把所有节点的值都收集起来；**现在你只需要把第 2 层（根节点视为第 0 层）的节点收集起来，就是大小为 2 的所有组合**：



![img](https://pic3.zhimg.com/v2-f04e55d12ad57a0a4afcd9e7d35544de_b.jpg)



反映到代码上，只需要稍改 base case，控制算法仅仅收集第 `k` 层节点的值即可：

代码：

```java
import java.util.ArrayList;
import java.util.List;

/*
 * @lc app=leetcode.cn id=77 lang=java
 *
 * [77] 组合
 */

// @lc code=start
class Solution {

    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        ArrayList<Integer> track = new ArrayList<>();
        backtrack(res, track, 1, n, k);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int start, int n, int k) {
        // 递归出口
        // 如果当前路径大小为k，则存入结果集
        if (k == track.size()) {
            res.add(new ArrayList<>(track));
            return;
        }

        // 回溯算法框架
        for (int i = start; i <= n; i++) {
            // 做选择
            track.add(i);
            // 进入下一层决策树
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(res, track, i + 1, n, k);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
// @lc code=end
```

#### 46. 全排列-中等

昨天做过，详情昨天的题解



### 元素可重不可复选-回溯+剪枝

刚才讲的标准子集问题输入的 `nums` 是没有重复元素的，但如果存在重复元素，怎么处理呢？

#### 90. 子集II-中等

给你一个整数数组 `nums`，其中可能包含重复元素，请你返回该数组所有可能的子集。

函数签名如下：

```text
List<List<Integer>> subsetsWithDup(int[] nums)
```

比如输入 `nums = [1,2,2]`，你应该输出：

```text
[ [],[1],[2],[1,2],[2,2],[1,2,2] ]
```

当然，按道理说集合不应该包含重复元素的，但既然题目这样问了，我们就忽略这个细节吧，仔细思考一下这道题怎么做才是正事。

就以 `nums = [1,2,2]` 为例，为了区别两个 `2` 是不同元素，后面我们写作 `nums = [1,2,2']`。

按照之前的思路画出子集的树形结构，显然，两条值相同的相邻树枝会产生重复：



![img](https://pic3.zhimg.com/v2-b50f8f5d55bd885c245b2d1fed9d0e1a_b.jpg)



```text
[ 
    [],
    [1],[2],[2'],
    [1,2],[1,2'],[2,2'],
    [1,2,2']
]
```

所以我们需要进行剪枝，如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历：



![img](https://pic3.zhimg.com/v2-befaa728e3c9d153fa361b49ae63f332_b.jpg)



**体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 `nums[i] == nums[i-1]`，则跳过**：

代码：

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * @lc app=leetcode.cn id=90 lang=java
 *
 * [90] 子集 II
 */

// @lc code=start
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 先排序，让相同的元素排在一起
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        ArrayList<Integer> track = new ArrayList<>();
        backtrack(res, track, 0, nums);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int start, int[] nums) {

        // 每一个节点都是一个子集
        res.add(new ArrayList<>(track));

        for (int i = start; i < nums.length; i++) {
            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            // 做选择
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(res, track, i + 1, nums);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
// @lc code=end
```

这段代码和之前标准的子集问题的代码几乎相同，就是添加了排序和剪枝的逻辑。

至于为什么要这样剪枝，结合前面的图应该也很容易理解，这样带重复元素的子集问题也解决了。

**我们说了组合问题和子集问题是等价的**，所以我们直接看一道组合的题目吧，这是力扣第 40 题「组合总和 II」：

#### 40. 组合总和II-中等

给你输入 `candidates` 和一个目标和 `target`，从 `candidates` 中找出中所有和为 `target` 的组合。

`candidates` 可能存在重复元素，且其中的每个数字最多只能使用一次。

说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 `candidates` 中所有和为 `target` 的子集。

所以这题怎么做呢？

对比子集问题的解法，只要额外用一个 `trackSum` 变量记录回溯路径上的元素和，然后将 base case 改一改即可解决这道题：

代码：

```java
/*
 * @lc app=leetcode.cn id=40 lang=java
 *
 * [40] 组合总和 II
 */

// @lc code=start
class Solution {

    // 记录track中元素总和
    int trackSum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        ArrayList<Integer> track = new ArrayList<>();
        if (candidates.length == 0) {
            return res;
        }
        // 先排序，让相同的元素靠在一起
        Arrays.sort(candidates);
        backtrack(res, track, 0, candidates, target);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int start, int[] candidates, int target) {
        // 递归出口
        // 如果当前路径总和为target，则存入结果集
        if (target == trackSum) {
            res.add(new ArrayList<>(track));
            return;
        }

        // 如果超过目标和，直接结束
        if (trackSum > target) {
            return;
        }

        // 回溯算法框架
        for (int i = start; i < candidates.length; i++) {
            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }

            // 做选择
            track.add(candidates[i]);
            // 记录元素总和
            trackSum += candidates[i];
            // 进入下一层决策树
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(res, track, i + 1, candidates, target);
            // 撤销选择
            track.remove(track.size() - 1);
            // 删除元素总和
            trackSum -= candidates[i];
        }
    }

}
// @lc code=end
```

排列问题的输入如果存在重复，比子集/组合问题稍微复杂一点，我们看看力扣第 47 题「全排列 II」：

#### 47. 全排列II

给你输入一个可包含重复数字的序列 `nums`，请你写一个算法，返回所有可能的全排列，函数签名如下：

```text
List<List<Integer>> permuteUnique(int[] nums)
```

比如输入 `nums = [1,2,2]`，函数返回：

```text
[ [1,2,2],[2,1,2],[2,2,1] ]
```

先看解法代码：

```java
/*
 * @lc app=leetcode.cn id=47 lang=java
 *
 * [47] 全排列 II
 */

// @lc code=start
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> track = new LinkedList<>();
    boolean[] used;

    public List<List<Integer>> permuteUnique(int[] nums) {
        // 先排序，让相同的元素靠在一起
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backtrack(nums);
        return res;
    }

    void backtrack(int[] nums) {
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            track.add(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.removeLast();
            used[i] = false;
        }
    }
}
// @lc code=end
```

你对比一下之前的标准全排列解法代码，这段解法代码只有两处不同：

1、对 `nums` 进行了排序。

2、添加了一句额外的剪枝逻辑。

类比输入包含重复元素的子集/组合问题，你大概应该理解这么做是为了防止出现重复结果。

但是注意排列问题的剪枝逻辑，和子集/组合问题的剪枝逻辑略有不同：新增了 `!used[i - 1]` 的逻辑判断。

这个地方理解起来就需要一些技巧性了，且听我慢慢到来。为了方便研究，依然把相同的元素用上标 `'` 以示区别。

假设输入为 `nums = [1,2,2']`，标准的全排列算法会得出如下答案：

```text
[
    [1,2,2'],[1,2',2],
    [2,1,2'],[2,2',1],
    [2',1,2],[2',2,1]
]
```

显然，这个结果存在重复，比如 `[1,2,2']` 和 `[1,2',2]` 应该只被算作同一个排列，但被算作了两个不同的排列。

所以现在的关键在于，如何设计剪枝逻辑，把这种重复去除掉？

**答案是，保证相同元素在排列中的相对位置保持不变**。

比如说 `nums = [1,2,2']` 这个例子，我保持排列中 `2` 一直在 `2'` 前面。

这样的话，你从上面 6 个排列中只能挑出 3 个排列符合这个条件：

```text
[ [1,2,2'],[2,1,2'],[2,2',1] ]
```

这也就是正确答案。

进一步，如果 `nums = [1,2,2',2'']`，我只要保证重复元素 `2` 的相对位置固定，比如说 `2 -> 2' -> 2''`，也可以得到无重复的全排列结果。

仔细思考，应该很容易明白其中的原理：

**标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。

那么反映到代码上，你注意看这个剪枝逻辑：

```java
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]
```

**当出现重复元素时，比如输入 `nums = [1,2,2',2'']`，`2'` 只有在 `2` 已经被使用的情况下才会被选择，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定**。

好了，这样包含重复输入的排列问题也解决了。



### 元素无重可复选

终于到了最后一种类型了：输入数组无重复元素，但每个元素可以被无限次使用。

直接看力扣第 39 题「组合总和」：

#### 39. 组合总和-中等

给你一个无重复元素的整数数组 `candidates` 和一个目标和 `target`，找出 `candidates` 中可以使数字和为目标数 `target` 的所有组合。`candidates` 中的每个数字可以无限制重复被选取。

函数签名如下：

```text
List<List<Integer>> combinationSum(int[] candidates, int target)
```

比如输入 `candidates = [1,2,3], target = 3`，算法应该返回：

```text
[ [1,1,1],[1,2],[3] ]
```

这道题说是组合问题，实际上也是子集问题：`candidates` 的哪些子集的和为 `target`？

想解决这种类型的问题，也得回到回溯树上，**我们不妨先思考思考，标准的子集/组合问题是如何保证不重复使用元素的**？

答案在于 `backtrack` 递归时输入的参数：

```text
// 回溯算法标准框架
for (int i = start; i < nums.length; i++) {
    // ...
    // 递归遍历下一层回溯树，注意参数
    backtrack(nums, i + 1, target);
    // ...
}
```

这个 `i` 从 `start` 开始，那么下一层回溯树就是从 `start + 1` 开始，从而保证 `nums[start]` 这个元素不会被重复使用：



![img](https://pic2.zhimg.com/v2-8110a7b8df79be6c6e6e42c6a6633769_b.jpg)



那么反过来，如果我想让每个元素被重复使用，我只要把 `i + 1` 改成 `i` 即可：

```text
// 回溯算法标准框架
for (int i = start; i < nums.length; i++) {
    // ...
    // 递归遍历下一层回溯树
    backtrack(nums, i, target);
    // ...
}
```

这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用：



![img](https://pic1.zhimg.com/v2-406ae565877779f74f504137b4b21afc_b.jpg)



当然，这样这棵回溯树会永远生长下去，所以我们的递归函数需要设置合适的 base case 以结束算法，即路径和大于 `target` 时就没必要再遍历下去了。

这道题的解法代码如下：

```java
/*
 * @lc app=leetcode.cn id=39 lang=java
 *
 * [39] 组合总和
 */

// @lc code=start
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯的路径
    LinkedList<Integer> track = new LinkedList<>();
    // 记录 track 中的路径和
    int trackSum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target);
        return res;
    }

    // 回溯算法主函数
    void backtrack(int[] nums, int start, int target) {
        // base case，找到目标和，记录结果
        if (trackSum == target) {
            res.add(new LinkedList<>(track));
            return;
        }
        // base case，超过目标和，停止向下遍历
        if (trackSum > target) {
            return;
        }

        // 回溯算法标准框架
        for (int i = start; i < nums.length; i++) {
            // 选择 nums[i]
            trackSum += nums[i];
            track.add(nums[i]);
            // 递归遍历下一层回溯树
            // 同一元素可重复使用，注意参数
            backtrack(nums, i, target);
            // 撤销选择 nums[i]
            trackSum -= nums[i];
            track.removeLast();
        }
    }
}
// @lc code=end
```

### 最后总结

来回顾一下排列/组合/子集问题的三种形式在代码上的区别。

由于子集问题和组合问题本质上是一样的，无非就是 base case 有一些区别，所以把这两个问题放在一起看。

**形式一、元素无重不可复选，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次**，`backtrack` 核心代码如下：

```text
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 取消选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式二、元素可重不可复选，即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次**，其关键在于排序和剪枝，`backtrack` 核心代码如下：

```java
Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 取消选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式三、元素无重可复选，即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次**，只要删掉去重逻辑即可，`backtrack` 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);

        backtrack(nums);
        // 取消选择
        track.removeLast();
    }
}
```

只要从树的角度思考，这些问题看似复杂多变，实则改改 base case 就能解决，这也是为什么我在 [学习算法和数据结构的框架思维](../算法思维系列/学习数据结构和算法的高效方法.md) 和 [手把手刷二叉树（纲领篇）](https://link.zhihu.com/?target=https%3A//labuladong.gitee.io/plugin-v3/%3Fqno%3D104) 中强调树类型题目重要性的原因。

如果你能够看到这里，真得给你鼓掌，相信你以后遇到各种乱七八糟的算法题，也能一眼看透它们的本质，以不变应万变。



## 1.6(链表专题)

今天复习一下链表，今天就总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：

1、合并两个有序链表

2、合并 `k` 个有序链表

3、寻找单链表的倒数第 `k` 个节点

4、寻找单链表的中点

5、判断单链表是否包含环并找出环起点

6、判断两个单链表是否相交并找出交点

这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。



#### 21. 合并两个有序链表-简单

我们的 while 循环每次比较 `p1` 和 `p2` 的大小，把较小的节点接到结果链表上：

![动图封面](https://picx.zhimg.com/v2-fd9a6009e608f1bd5c1da481f1552c86_720w.jpg?source=d16d100b)



这个算法的逻辑类似于「拉拉链」，`l1, l2` 类似于拉链两侧的锯齿，指针 `p` 就好像拉链的拉索，将两个有序链表合并。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `head` 节点**。你可以试试，如果不使用 `head` 虚拟节点，代码会复杂很多，而有了 `head` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

这题比较简单，我们直接看解法：

```java
/*
 * @lc app=leetcode.cn id=21 lang=java
 *
 * [21] 合并两个有序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 虚拟头节点
        ListNode head = new ListNode();
        ListNode p = head;
        ListNode p1 = list1, p2 = list2;

        while (p1 != null && p2 != null) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1.val > p2.val) {
                ListNode t = new ListNode(p2.val);
                p.next = t;
                p = t;
                p2 = p2.next;
            } else {
                ListNode t = new ListNode(p1.val);
                p.next = t;
                p = t;
                p1 = p1.next;
            }
        }
        if (p1 != null) {
            p.next = p1;
        }
        if (p2 != null) {
            p.next = p2;
        }

        return head.next;
    }
}
// @lc code=end

```

#### 23. 合并k个有序链表-困难

合并 `k` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 `k` 个节点中的最小节点，接到结果链表上？

这里我们就要用到 [优先级队列（二叉堆）](http://link.zhihu.com/?target=https%3A//labuladong.gitee.io/algo/) 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 `k` 个节点中的最小节点：

```java
import java.util.PriorityQueue;

/*
 * @lc app=leetcode.cn id=23 lang=java
 *
 * [23] 合并K个升序链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) {
            return null;
        }
        // 建立虚拟头节，存储合并后的链表
        ListNode head = new ListNode();
        ListNode p = head;

        // 建立优先队列，小根堆
        PriorityQueue<ListNode> heap = new PriorityQueue<>(
                lists.length, (a, b) -> (a.val - b.val));
        // 将n个链表的头节点加入小根堆
        for (ListNode t : lists) {
            if (t != null) {
                heap.add(t);
            }
        }

        while (!heap.isEmpty()) {
            // 获取最小节点，并加入到新链表中
            ListNode t = heap.poll();
            p.next = t;
            if (t.next != null) {
                t = t.next;
                heap.add(t);
            }
            // p向前推进
            p = p.next;
        }

        return head.next;
    }
}

// @lc code=end
```

这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 `pq` 中的元素个数最多是 `k`，所以一次 `poll` 或者 `add` 方法的时间复杂度是 `O(logk)`；所有的链表节点都会被加入和弹出 `pq`，**所以算法整体的时间复杂度是 `O(Nlogk)`，其中 `k` 是链表的条数，`N` 是这些链表的节点总数**。



#### 19. 删除链表的倒数第 N 个结点-中等

这道题1.3日做过，这里回顾一下

从前往后寻找单链表的第 `k` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 `k` 个节点呢？

那你可能说，假设链表有 `n` 个节点，倒数第 `k` 个节点就是正数第 `n - k` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 `ListNode` 头结点代表一条单链表，你不能直接得出这条链表的长度 `n`，而需要先遍历一遍链表算出 `n` 的值，然后再遍历链表计算第 `n - k` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 `k` 个节点。

那么，我们能不能**只遍历一次链表**，就算出倒数第 `k` 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 `k = 2`，思路如下：

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![img](https://pic1.zhimg.com/80/v2-e8ef15bf6e3484ed99ad363cb1175ff9_720w.webp?source=d16d100b)

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`：

![img](https://picx.zhimg.com/80/v2-24df62dcfacc1b7b8259e43a7ab23ef2_720w.webp?source=d16d100b)

接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时走了 `n - k` 步，`p2` 也走了 `n - k` 步，也就是链表的倒数第 `k` 个节点：

![img](https://picx.zhimg.com/80/v2-47fbb5743e09c86805db8e8ec3b88c73_720w.webp?source=d16d100b)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

上述逻辑的代码如下：

```java
// 返回链表的倒数第 k 个节点
ListNode findFromEnd(ListNode head, int k) {
    ListNode p1 = head;
    // p1 先走 k 步
    for (int i = 0; i < k; i++) {
        p1 = p1.next;
    }
    ListNode p2 = head;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 现在指向第 n - k 个节点
    return p2;
}
```

当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是 `O(N)`，但上述这个算法更有技巧性。

很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「删除链表的倒数第 N 个结点」：

![img](https://pica.zhimg.com/80/v2-0d980eac4d141c1d829a55f8dd9d0142_720w.webp?source=d16d100b)

我们直接看解法代码：

```java
// 主函数
public ListNode removeNthFromEnd(ListNode head, int n) {
    // 虚拟头结点
    ListNode dummy = new ListNode(-1);
    dummy.next = head;
    // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
    ListNode x = findFromEnd(dummy, n + 1);
    // 删掉倒数第 n 个节点
    x.next = x.next.next;
    return dummy.next;
}

private ListNode findFromEnd(ListNode head, int k) {
    // 代码见上文
}
```

这个逻辑就很简单了，要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的引用，可以用我们实现的 `findFromEnd` 来操作。

不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。

但有了我们虚拟节点 `dummy` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。



#### 876. 链表的中间结点-简单

这个技巧在前文 [双指针技巧汇总](http://link.zhihu.com/?target=https%3A//labuladong.gitee.io/algo/) 写过，如果看过的读者可以跳过。

力扣第 876 题「链表的中间结点」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 `n`，常规方法也是先遍历链表计算 `n`，再遍历一次得到第 `n / 2` 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：

我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。

**每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

上述思路的代码实现如下：

```java
/*
 * @lc app=leetcode.cn id=876 lang=java
 *
 * [876] 链表的中间结点
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow, fast;
        slow = fast = head;
        while (fast != null && fast.next != null) {
            // 慢指针走一步，快指针走两步
            slow = slow.next;
            fast = fast.next.next;
        }
        // 慢指针指向中点
        return slow;
    }
}
// @lc code=end
```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。



#### 141. 环形链表-简单

判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：

每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。

如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：

```java
boolean hasCycle(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
        // 快慢指针相遇，说明含有环
        if (slow == fast) {
            return true;
        }
    }
    // 不包含环
    return false;
}
```



当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？

#### 142. 环形链表II-中等

这里简单提一下解法：

```java
/*
 * @lc app=leetcode.cn id=142 lang=java
 *
 * [142] 环形链表 II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow)
                break;

        }
        // 上面的代码类似 hasCycle 函数
        if (fast == null || fast.next == null) {
            // fast 遇到空指针说明没有环
            return null;
        }

        // 将slow重新指向头节点
        slow = head;

        // 将两节点同时前进，相交的点就是环形起点
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
// @lc code=end

```

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

为什么要这样呢？这里简单说一下其中的原理。

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

[![img](https://labuladong.gitee.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/3.jpeg)](https://labuladong.gitee.io/algo/images/双指针/3.jpeg)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

[![img](https://labuladong.gitee.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/2.jpeg)](https://labuladong.gitee.io/algo/images/双指针/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。



#### 160. 相交链表

给你输入两个链表的头结点 `headA` 和 `headB`，这两个链表可能存在相交。

如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。

比如题目给我们举的例子，如果输入的两个链表如下图：

[![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/4.png)](https://labuladong.gitee.io/algo/images/链表技巧/4.png)

那么我们的算法应该返回 `c1` 这个节点。

这个题直接的想法可能是用 `HashSet` 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。

如果不用额外的空间，只使用两个指针，你如何做呢？

难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

[![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/5.jpeg)](https://labuladong.gitee.io/algo/images/链表技巧/5.jpeg)

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 `c1`。

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`**。

所以，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

[![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg)](https://labuladong.gitee.io/algo/images/链表技巧/6.jpeg)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 `c1` 节点是 null 空指针嘛，可以正确返回 null。

按照这个思路，可以写出如下代码：

```java
/*
 * @lc app=leetcode.cn id=160 lang=java
 *
 * [160] 相交链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1 指向 A 链表头结点，p2 指向 B 链表头结点
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1 走一步，如果走到 A 链表末尾，转到 B 链表
            if (p1 == null)
                p1 = headB;
            else
                p1 = p1.next;
            // p2 走一步，如果走到 B 链表末尾，转到 A 链表
            if (p2 == null)
                p2 = headA;
            else
                p2 = p2.next;
        }
        return p1;
    }
}
// @lc code=end

```

这样，这道题就解决了，空间复杂度为 `O(1)`，时间复杂度为 `O(N)`。

##### 拓展：

如果把两条链表首尾相连，那么「寻找两条链表的交点」的问题转换成了前面讲的「寻找环起点」的问题：

[![img](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/7.png)](https://labuladong.gitee.io/algo/images/链表技巧/7.png)

说实话我没有想到这种思路，不得不说这是一个很巧妙的转换！不过需要注意的是，这道题说不让你改变原始链表的结构，所以你把题目输入的链表转化成环形链表求解之后记得还要改回来，否则无法通过。

另外，还有读者提到，既然「寻找两条链表的交点」的核心在于让 `p1` 和 `p2` 两个指针能够同时到达相交节点 `c1`，那么可以通过预先计算两条链表的长度来做到这一点，具体代码如下：

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lenA = 0, lenB = 0;
    // 计算两条链表的长度
    for (ListNode p1 = headA; p1 != null; p1 = p1.next) {
        lenA++;
    }
    for (ListNode p2 = headB; p2 != null; p2 = p2.next) {
        lenB++;
    }
    // 让 p1 和 p2 到达尾部的距离相同
    ListNode p1 = headA, p2 = headB;
    if (lenA > lenB) {
        for (int i = 0; i < lenA - lenB; i++) {
            p1 = p1.next;
        }
    } else {
        for (int i = 0; i < lenB - lenA; i++) {
            p2 = p2.next;
        }
    }
    // 看两个指针是否会相同，p1 == p2 时有两种情况：
    // 1、要么是两条链表不相交，他俩同时走到尾部空指针
    // 2、要么是两条链表相交，他俩走到两条链表的相交点
    while (p1 != p2) {
        p1 = p1.next;
        p2 = p2.next;
    }
    return p1;
}
```

虽然代码多一些，但是时间复杂度是还是 `O(N)`，而且会更容易理解一些。



## 1.7

今天也学习几个链表题目

### 复习题目：

#### 206. 反转链表-简单

迭代方法实现比较老套，这里用递归实现：

```java
/*
 * @lc app=leetcode.cn id=206 lang=java
 *
 * [206] 反转链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * 优雅的递归实现
     * 
     * @param head
     * @return
     */
    public ListNode reverseList(ListNode head) {
        // 递归出口
        if (head == null || head.next == null) {
            return head;
        }
        ListNode last = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return last;
    }
}
// @lc code=end
```



### 新题：

#### 92. 反转链表II-中等

现在解决我们最开始提出的问题，给一个索引区间 `[m, n]`（索引从 1 开始），仅仅反转区间中的链表元素。

```java
ListNode reverseBetween(ListNode head, int m, int n)
```

首先，如果 `m == 1`，就相当于反转链表开头的 `n` 个元素嘛，也就是我们刚才实现的功能：

```java
ListNode reverseBetween(ListNode head, int m, int n) {
    // base case
    if (m == 1) {
        // 相当于反转前 n 个元素
        return reverseN(head, n);
    }
    // ...
}
```

如果 `m != 1` 怎么办？如果我们把 `head` 的索引视为 1，那么我们是想从第 `m` 个元素开始反转对吧；如果把 `head.next` 的索引视为 1 呢？那么相对于 `head.next`，反转的区间应该是从第 `m - 1` 个元素开始的；那么对于 `head.next.next` 呢……

区别于迭代思想，这就是递归思想，所以我们可以完成代码：

```java
/*
 * @lc app=leetcode.cn id=92 lang=java
 *
 * [92] 反转链表 II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    /**
     * 反转部分链表的递归实现
     * 
     * @param head
     * @param left
     * @param right
     * @return
     */
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left == 1) {
            return reverseN(head, right);
        }
        // 前进到反转的起点触发 base case
        head.next = reverseBetween(head.next, left - 1, right - 1);
        return head;
    }

    ListNode successor = null; // 后驱节点
    // 将链表的前 n 个节点反转（n <= 链表长度）

    public ListNode reverseN(ListNode head, int n) {
        // 递归出口
        if (n == 1) {
            // 记录n+1个节点
            successor = head.next;
            return head;
        }
        ListNode last = reverseN(head.next, n - 1);
        head.next.next = head;
        head.next = successor;
        return last;
    }
}
// @lc code=end
```

递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。

处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题。

值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)。所以递归操作链表可以作为对递归算法的练习或者拿去和小伙伴装逼，但是考虑效率的话还是使用迭代算法更好。

最后，我在数据结构精品课中讲解了 [单链表的递归实现](https://aep.h5.xeknow.com/s/1RQzXc)，应该能够让你进一步加深对递归的理解。



#### 234. 回文链表

输入一个单链表的头结点，判断这个链表中的数字是不是回文，函数签名如下：

```java
boolean isPalindrome(ListNode head);
```

比如说：

```
输入: 1->2->null
输出: false

输入: 1->2->2->1->null
输出: true
```

这道题的关键在于，单链表无法倒着遍历，无法使用双指针技巧。

那么最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。关于如何反转链表，可以参见前文 [递归翻转链表的一部分](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/di-gui-mo--1eaae/)。

其实，**借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表**，下面来具体聊聊。

对于二叉树的几种遍历方式，我们再熟悉不过了：

```java
void traverse(TreeNode root) {
    // 前序遍历代码
    traverse(root.left);
    // 中序遍历代码
    traverse(root.right);
    // 后序遍历代码
}
```

在 [学习数据结构的框架思维](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/) 中说过，链表兼具递归结构，树结构不过是链表的衍生。那么，**链表其实也可以有前序遍历和后序遍历**：

```java
void traverse(ListNode head) {
    // 前序遍历代码
    traverse(head.next);
    // 后序遍历代码
}
```

这个框架有什么指导意义呢？如果我想正序打印链表中的 `val` 值，可以在前序遍历位置写代码；反之，如果想倒序遍历链表，就可以在后序遍历位置操作：

```java
/* 倒序打印单链表中的元素值 */
void traverse(ListNode head) {
    if (head == null) return;
    traverse(head.next);
    // 后序遍历代码
    print(head.val);
}
```

说到这了，其实可以稍作修改，模仿双指针实现回文判断的功能：



```java
/*
 * @lc app=leetcode.cn id=234 lang=java
 *
 * [234] 回文链表
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    ListNode left = null;

    public boolean isPalindrome(ListNode head) {
        left = head;
        return traverse(head);
    }

    public boolean traverse(ListNode right) {
        // 递归出口
        if (right == null) {
            return true;
        }
        boolean res = traverse(right.next);
        // 后序遍历代码
        res = res && (right.val == left.val);
        left = left.next;
        return res;
    }
}
// @lc code=end
```

这么做的核心逻辑是什么呢？**实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的**，只不过我们利用的是递归函数的堆栈而已，如下 GIF 所示：

[![img](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/1.gif)](https://labuladong.gitee.io/algo/images/回文链表/1.gif)

当然，无论造一条反转链表还是利用后序遍历，算法的时间和空间复杂度都是 O(N)。下面我们想想，能不能不用额外的空间，解决这个问题呢？

##### 空间复杂度优化

更好的思路是这样的：

**1、先通过 [双指针技巧](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-8f30d/shuang-zhi-0f7cc/) 中的快慢指针来找到链表的中点**：

```java
ListNode slow, fast;
slow = fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
// slow 指针现在指向链表中点
```

[![img](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/1.jpg)](https://labuladong.gitee.io/algo/images/回文链表/1.jpg)

**2、如果`fast`指针没有指向`null`，说明链表长度为奇数，`slow`还要再前进一步**：

```java
if (fast != null)
    slow = slow.next;
```

[![img](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/2.jpg)](https://labuladong.gitee.io/algo/images/回文链表/2.jpg)

**3、从`slow`开始反转后面的链表，现在就可以开始比较回文串了**：

```java
ListNode left = head;
ListNode right = reverse(slow);

while (right != null) {
    if (left.val != right.val)
        return false;
    left = left.next;
    right = right.next;
}
return true;
```

[![img](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/3.jpg)](https://labuladong.gitee.io/algo/images/回文链表/3.jpg)

至此，把上面 3 段代码合在一起就高效地解决这个问题了，其中 `reverse` 函数很容易实现：

```java
boolean isPalindrome(ListNode head) {
    ListNode slow, fast;
    slow = fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    if (fast != null)
        slow = slow.next;
    
    ListNode left = head;
    ListNode right = reverse(slow);
    while (right != null) {
        if (left.val != right.val)
            return false;
        left = left.next;
        right = right.next;
    }
    
    return true;
}

ListNode reverse(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

算法过程如下 GIF 所示：

[![img](https://labuladong.gitee.io/algo/images/kgroup/8.gif)](https://labuladong.gitee.io/algo/images/kgroup/8.gif)

算法总体的时间复杂度 O(N)，空间复杂度 O(1)，已经是最优的了。

我知道肯定有读者会问：这种解法虽然高效，但破坏了输入链表的原始结构，能不能避免这个瑕疵呢？

其实这个问题很好解决，关键在于得到`p, q`这两个指针位置：

[![img](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/4.jpg)](https://labuladong.gitee.io/algo/images/回文链表/4.jpg)

这样，只要在函数 return 之前加一段代码即可恢复原先链表顺序：

```java
p.next = reverse(q);
```

篇幅所限，我就不写了，读者可以自己尝试一下。







