# 寒假学习打卡



## 1.2

### 复习题目：

#### 2. 两数相加-中等(模拟法)

**模拟法解决**

代码：

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //使用带头节点的单链表来存储答案
        ListNode head = new ListNode();
        ListNode p = head;
        
        int carry = 0;
        //当l1和l2都为null的时候退出循环
        while (!(l1 == null && l2 == null)) {
            //将两个链表中的值都给取出来
            int a = l1 != null ? l1.val : 0;
            int b = l2 != null ? l2.val : 0;
            //相加
            int sum = a + b + carry;
            //求出下一位，以及进位
            carry = sum / 10;
            sum = sum % 10;
            //新建结点
            ListNode t = new ListNode(sum);
            p.next = t;
            p = p.next;

            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
    
        //加上最后一位
        if (carry == 1) {
            p.next = new ListNode(1);
        }    

        return head.next;
    }
}
```



#### 3. 无重复字符的最长子串-中等(滑动窗口)

**滑动窗口解决**

什么是滑动窗口？

其实就是一个队列,比如例题中的 `abcabcbb`，进入这个队列（窗口）为 `abc` 满足题目要求，当再进入 `a`，队列变成了 `abca`，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

时间复杂度：O(n)

代码：

```java
class Solution {
    /**
        滑动窗口解决
     */
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        //分别记录最长窗口和当前窗口的左边界
        int max, left;
        max = left = 0;
        //记录已遍历的字符及其所在的下标
        Map<Character, Integer> map = new HashMap<>();
        
        //开始遍历
        for (int i = 0; i < s.length(); i++) {
            //如果该字母已经在哈希表中
            if (map.containsKey(s.charAt(i))) {
                //将左边界移动到该该字母的下标+1的位置，这里防止左边界回移，取left与其比较
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i - left + 1);
        }

        return max;
    }
}
```

### 新题：

#### 4. 寻找两个正序数组的中位数-困难(二分法)

**二分法解决-等价寻找第k大的数**

代码：

```java
class Solution {
    /**
        二分法解决
    
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n, m, left, right;
        n = nums1.length;
        m = nums2.length;
        left = (n + m + 1) / 2;
        right = (n + m + 2) / 2;
        return (
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) +
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)
            ) * 0.5;
    }

    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让len1的长度小于len2，这样就能保证如果有数组空了，一定是len1 
        if (len1 > len2) {
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        //如果len1为空，退出递归
        if (len1 == 0) {
            return nums2[start2 + k - 1];
        }
        //k为1
        if (k == 1) {
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(k / 2, len1) - 1;
        int j = start2 + Math.min(k / 2, len2) - 1;
        if (nums1[i] < nums2[j]) {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        } else {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
    }
}
```

#### 15. 三数之和-中等(线性枚举+二分法)

**采用线性枚举+二分法解**

该题可以转化为nums[i] + nums[j] = -nums[k]

代码：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // 该题可以转化为nums[i] + nums[j] = -nums[k]
        // 采用线性枚举+二分法解
        List<List<Integer>> res = new ArrayList<>();
        int n = nums.length;
        //先对nums进行排序
        Arrays.sort(nums);
        for (int k = 0; k < n; k++) {
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            if (nums[k] > 0) {
                break;
            }

            int i = k + 1, j = n - 1;
            while (i < j) {
                if (nums[i] + nums[j] > -nums[k]) {
                    j--;
                } else if (nums[i] + nums[j] < -nums[k]) {
                    i++;
                } else {
                    res.add(new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[k])));
                    j--;
                    i++;
                    //可能会出现连续重复的数
                    while (i < j && nums[i] == nums[i + 1]) i++;
                    while (i < j && nums[j] == nums[j - 1]) j--;
                }
            }
        }

        return res;
    }
}
```





## 1.3

今天的目标是学习巩固动态规划！

### 复习题目：

#### 5. 最长回文子串-中等(动态规划)

**经典的动态规划题**

定义状态`dp[i][j]`为i到j是否为回文串

初始化状态：每个大小为1的子串都是回文串

状态转移方程为：

​	如果`s[i] == s[j]`，且`dp[i + 1][j - 1] == 1`，则`dp[i][j] = 1`，这里有特殊情况，如果该子串大小小与等于3时候，则直接为1

​	如果`s[i] != s[j]`，则`dp[i][j] = 0`

代码：

```java
class Solution {
    /**
    动态规划求解
     */
    public String longestPalindrome(String s) {
        //定义状态
        int n = s.length();
        int[][] dp = new int[n][n];
        //初始化状态
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        int left = 0;
        int maxLen = 1;
        //状态转移
        //枚举子串长度
        for (int l = 2; l <= n; l++) {
            //遍历字符串
            for (int i = 0; i < n; i++) {
                //确定右边界
                int j = i + l - 1;
                //右边界越界情况
                if (j >= n) {
                    break;
                }

                if (s.charAt(i) != s.charAt(j)) {
                    dp[i][j] = 0;
                } else {
                    if (j - i <= 2) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                //如果当前dp[i][j]为1，且长度大于目前最大长度，则记录当前长度以及下标
                if (dp[i][j] == 1 && l > maxLen) {
                    maxLen = l;
                    left = i;
                }
            }
        }
        return s.substring(left, left + maxLen);
    }
}
```

#### 198. 打家劫舍-中等(动态规划)

**经典动态规划题**

- 定义状态，`dp[i]`表示已i为结尾能打劫到最大的钱的大小

- 初始化状态，`dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`

- 写出状态转移方程，`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int rob(int[] nums) {
        int n = nums.length;
        //定义状态
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        if (n == 1) {
            return dp[0];   
        }
        dp[1] = Math.max(nums[0], nums[1]);

        //状态转移方程
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
```







### 新题：

#### 10. 正则表达式匹配-困难(动态规划)

**二维动态规划**

1. 定义状态

    `dp[i][j]`表示当字符串长度分别为i、j时，s与p是否匹配

2. 写出状态转移方程

    1. 当`p[j] = '.'或s[i]`时，`dp[i][j] = dp[i - 1][j - 1]`
    2. 当`p[j] = '*'`时
        1. `p[j - 1] != s[i]`，表示不匹配时候，`dp[i][j] = dp[i][j - 2]`
        2. `p[j - 1] != s[i]`，表示匹配的时候，接下来分**3种情况**讨论
            1. 当`*`匹配0个，`dp[i][j] = dp[i][j - 2]`
            2. 当`*`匹配1个，`dp[i][j] = dp[i][j - 1]`
            3. 当`*`匹配2个或更多，`dp[i][j] = dp[i - 1][j]`

代码如下：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        //空字符串处理
        if (s == null || p == null) {
            return true;
        }

        int n, m;
        n = s.length();
        m = p.length();
        //定义状态
        boolean[][] dp = new boolean[n + 1][m + 1];
        //初始化状态
        dp[0][0] = true;
        for (int i = 2; i <= m; i++) {
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = dp[0][i - 2];
            }
        }

        //状态转移
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                //当j不为*
                if (p.charAt(j - 1) != '*') {
                    if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    //第j-1个字符不匹配
                    if (p.charAt(j - 2) != s.charAt(i - 1) && p.charAt(j - 2) != '.') {
                        dp[i][j] = dp[i][j - 2];
                    } else {
                        dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j];
                    }
                }
            }
        }

        return dp[n][m];
    }
  
}
```

#### 19. 删除链表的倒数第 N 个结点-中等(双指针)

**双指针解决问题**

代码：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode quick, slow;
        //先定义一个指针，让他移动n次
        quick = head;
        for (int i = 0; i < n; i++) {
            quick = quick.next;
        }
        if (quick == null) {
            //说明删除的是头节点
            return head.next;
        }
        //再定义慢指针，该指针从head出发
        slow = head;
        while (quick.next != null) {
            slow = slow.next;
            quick = quick.next;
        }
        //删除slow的下一个结点
        slow.next = slow.next.next;

        return head;
    }
}
```

#### 740. 删除并获得点数-中等(动态规划)

这题也是动态规划，和上面的打家劫舍有异曲同工之妙

代码：

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = 0;
        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }
        int[] sum = new int[maxVal + 1];
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }

    public int rob(int[] nums) {
        int size = nums.length;
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```





## 1.4

今天也学几个动态规划题目，顺便预热下回溯算法

### 复习题目：

#### 53. 最大子数组和-中等(动态规划)

直接看代码，**简单动态规划题**

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        //定义状态
        //dp[i]表示以i为结尾的子数组的最大和
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        int res = dp[0];

        //状态转移
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); 
            if (res < dp[i]) {
                res = dp[i];
            }
        }

        return res;
    }
}
```



#### 46. 全排列-中等(回溯)

回溯算法的套路：[回溯算法套路详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93530380?utm_campaign=&utm_medium=social&utm_oi=963759403787276288&utm_psn=1594052365698420736&utm_source=qq)

##### 回溯算法的框架：

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

代码：

```java
class Solution {
    /**
    符合回溯算法框架
     */

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        dfs(res, nums, new ArrayList<>());
        return res;
    }

    public void dfs(List<List<Integer>> res, int[] nums, List<Integer> track) {
        //递归出口
        int n = nums.length;
        if (track.size() == n) {
            res.add(new ArrayList(track));
            return;
        }

        for (int i = 0; i < n; i++) {
            //排除不合法情况
            if (track.contains(nums[i])) {
                continue;
            }
            //做选择
            track.add(nums[i]);
            //进入下一层决策树
            dfs(res, nums, track);
            //撤销选择
            track.remove(track.size() - 1);
        }

    }
}
```

![截屏2023-01-04 19.29.58](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2019.29.58.png)

### 新题：

#### 322. 零钱兑换-中等(动态规划)

**动态规划题**

1. 定义状态

    `dp[i]`表示凑出i块钱最少需要多少硬币

2. 写出状态转移方程

    对于`coin[j]`这个硬币，这里有两种情况

    - 选取该硬币

        `dp[i] = dp[i-coins[j] ] + 1`，不过这里还需要注意，在选的时候，还得考虑 `coins[j]` 是否比 i 大，如果比 i 大的话，显然是不能选的。

    - 不选取该硬币

        `dp[i] = dp[i]`

3. 初始值就比较简单了，当 i = 0 时，显然有 dp[0] = 0。

    不过这里需要注意的是，我们还需要给所有 dp[i] 都赋予一个初始值，否则在递推公式 dp[i] = min(dp[i], dp[i – coins[j]] + 1) 的过程中，dp[i] 有可能会被初始值覆盖，所以我们得给 dp[i] 赋上一个**尽量大**的初始值，可以赋值为 amout + 1。

    详情看代码吧，有些细节需要在代码，才更好说明

代码：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //定义状态
        //dp[i]表示凑出i块钱最少需要多少硬币
        int[] dp = new int[amount + 1];
        //初始化状态 
        // 这里我们还得给dp[i]赋予一个尽量大的初始值
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        //写出状态转移方程
        for (int i = 1; i <= amount; i++) {
            //计算dp[i]所需最少硬币的数量
            for (int j = 0; j < coins.length; j++) {
                //总金额一定大于硬币大小
                if (i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

![截屏2023-01-04 18.29.13](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2018.29.13.png)



#### 20. 有效的括号-简单(栈)

**考察栈的概念**

代码：

```java
class Solution {
    /**
    考察栈的基本概念--先进后出
     */
    public boolean isValid(String s) {
        //新建一个哈希表
        Map<Character, Character> map = new HashMap<>(){{
            put('(', ')'); 
            put('{', '}');
            put('[', ']');
            put('?', '?');
        }};

        if(s.length() > 0 && !map.containsKey(s.charAt(0))) {
            return false;
        }

        LinkedList<Character> stack = new LinkedList<Character>() {{
             add('?');
        }};

        for(Character c : s.toCharArray()){
            if(map.containsKey(c)) { 
                stack.addLast(c);
            } else if(map.get(stack.removeLast()) != c) {
                return false;
            }
        }
        return stack.size() == 1;
    }
}
```

![截屏2023-01-04 18.46.49](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2018.46.49.png)

#### 22. 括号生成-中等(回溯)

**经典回溯算法**

代码：

```java
class Solution {
    /**
    回溯解法
     */
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        dfs(n, res, 0, 0, "");
        return res;
    }

    public void dfs(int n, List<String> res, int left, int right, String str) {
        //递归出口
        if (left < right) {
            return;
        }
        if (left == right && right == n) {
            res.add(str);
            return;
        }

        if (left < n) {
            //加左括号
            dfs(n, res, left + 1, right, str + "(");
        }
        if (right < left) {
            //加右括号
            dfs(n, res, left, right + 1, str + ")");
        }
    }
}
```

![截屏2023-01-04 19.14.07](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2019.14.07.png)





## 1.5(回溯专题)

**今天的主要目标是强化回溯算法**

解决所有**排列组合子集**题目

### 元素无重不可复选-回溯

#### 78. 子集-中等

以下为转载内容

**作者：labuladong**
**链接：https://zhuanlan.zhihu.com/p/474532978**
**来源：知乎**
**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**

题目给你输入一个无重复元素的数组 `nums`，其中每个元素最多使用一次，请你返回 `nums` 的所有子集。

函数签名如下：

```java
List<List<Integer>> subsets(int[] nums)
```

比如输入 `nums = [1,2,3]`，算法应该返回如下子集：

```java
[ [],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3] ]
```

好，我们暂时不考虑如何用代码实现，先回忆一下我们的高中知识，如何手推所有子集？

首先，生成元素个数为 0 的子集，即空集 `[]`，为了方便表示，我称之为 `S_0`。

然后，在 `S_0` 的基础上生成元素个数为 1 的所有子集，我称为 `S_1`：



![img](https://pic3.zhimg.com/v2-35a0e5200b2002e31770bb21d006a062_b.jpg)



接下来，我们可以在 `S_1` 的基础上推导出 `S_2`，即元素个数为 2 的所有子集：



![img](https://pic3.zhimg.com/v2-e2cfa9ecc7df1750c43c1eda73cea862_b.jpg)



为什么集合 `[2]` 只需要添加 `3`，而不添加前面的 `1` 呢？

因为集合中的元素不用考虑顺序， `[1,2,3]` 中 `2` 后面只有 `3`，如果你向前考虑 `1`，那么 `[2,1]` 会和之前已经生成的子集 `[1,2]` 重复。

**换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集**。

接着，我们可以通过 `S_2` 推出 `S_3`，实际上 `S_3` 中只有一个集合 `[1,2,3]`，它是通过 `[1,2]` 推出的。

整个推导过程就是这样一棵树：



![img](https://pic4.zhimg.com/v2-1157a7e0f73d524a5da6a345742f3903_b.jpg)



注意这棵树的特性：

**如果把根节点作为第 0 层，将每个节点和根节点之间树枝上的元素作为该节点的值，那么第 `n` 层的所有节点就是大小为 `n` 的所有子集**。

你比如大小为 2 的子集就是这一层节点的值：



![img](https://pic3.zhimg.com/v2-f04e55d12ad57a0a4afcd9e7d35544de_b.jpg)



> **PS：注意，本文之后所说「节点的值」都是指节点和根节点之间树枝上的元素，且将根节点认为是第 0 层**。

那么再进一步，如果想计算所有子集，那只要遍历这棵多叉树，把所有节点的值收集起来不就行了？

代码：

```java
import java.util.ArrayList;
import java.util.List;

/*
 * @lc app=leetcode.cn id=78 lang=java
 *
 * [78] 子集
 */

// @lc code=start
class Solution {

    public List<List<Integer>> subsets(int[] nums) {
        // 结果集
        List<List<Integer>> res = new ArrayList<>();
        // 存放路径
        List<Integer> track = new ArrayList<>();
        backtrack(res, track, nums, 0);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int[] nums, int start) {

        // 每个节点都是一个结果集
        res.add(new ArrayList<>(track));

        // 回溯算法的基本框架
        for (int i = start; i < nums.length; i++) {
            // 做选择
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(res, track, nums, i + 1);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
// @lc code=end
```

看过前文 [回溯算法核心框架](https://link.zhihu.com/?target=https%3A//labuladong.gitee.io/plugin-v3/%3Fqno%3D51) 的读者应该很容易理解这段代码把，我们使用 `start` 参数控制树枝的生长避免产生重复的子集，用 `track` 记录根节点到每个节点的路径的值，同时在前序位置把每个节点的路径值收集起来，完成回溯树的遍历就收集了所有子集：



![img](https://pic4.zhimg.com/v2-1157a7e0f73d524a5da6a345742f3903_b.jpg)



最后，`backtrack` 函数开头看似没有 base case，会不会进入无限递归？

其实不会的，当 `start == nums.length` 时，叶子节点的值会被装入 `res`，但 for 循环不会执行，也就结束了递归。



#### 77. 组合-中等

**作者：labuladong**
**链接：https://zhuanlan.zhihu.com/p/474532978**
**来源：知乎**
**著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。**

如果你能够成功的生成所有无重子集，那么你稍微改改代码就能生成所有无重组合了。

你比如说，让你在 `nums = [1,2,3]` 中拿 2 个元素形成所有的组合，你怎么做？

稍微想想就会发现，大小为 2 的所有组合，不就是所有大小为 2 的子集嘛。

**所以我说组合和子集是一样的：大小为 `k` 的组合就是大小为 `k` 的子集**。

比如力扣第 77 题「组合」：

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

函数签名如下：

```java
List<List<Integer>> combine(int n, int k)
```

比如 `combine(3, 2)` 的返回值应该是：

```text
[ [1,2],[1,3],[2,3] ]
```

这是标准的组合问题，但我给你翻译一下就变成子集问题了：

**给你输入一个数组 `nums = [1,2..,n]` 和一个正整数 `k`，请你生成所有大小为 `k` 的子集**。

还是以 `nums = [1,2,3]` 为例，刚才让你求所有子集，就是把所有节点的值都收集起来；**现在你只需要把第 2 层（根节点视为第 0 层）的节点收集起来，就是大小为 2 的所有组合**：



![img](https://pic3.zhimg.com/v2-f04e55d12ad57a0a4afcd9e7d35544de_b.jpg)



反映到代码上，只需要稍改 base case，控制算法仅仅收集第 `k` 层节点的值即可：

代码：

```java
import java.util.ArrayList;
import java.util.List;

/*
 * @lc app=leetcode.cn id=77 lang=java
 *
 * [77] 组合
 */

// @lc code=start
class Solution {

    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        ArrayList<Integer> track = new ArrayList<>();
        backtrack(res, track, 1, n, k);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int start, int n, int k) {
        // 递归出口
        // 如果当前路径大小为k，则存入结果集
        if (k == track.size()) {
            res.add(new ArrayList<>(track));
            return;
        }

        // 回溯算法框架
        for (int i = start; i <= n; i++) {
            // 做选择
            track.add(i);
            // 进入下一层决策树
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(res, track, i + 1, n, k);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
// @lc code=end
```

#### 46. 全排列-中等

昨天做过，详情昨天的题解



### 元素可重不可复选-回溯+剪枝

刚才讲的标准子集问题输入的 `nums` 是没有重复元素的，但如果存在重复元素，怎么处理呢？

#### 90. 子集II-中等

给你一个整数数组 `nums`，其中可能包含重复元素，请你返回该数组所有可能的子集。

函数签名如下：

```text
List<List<Integer>> subsetsWithDup(int[] nums)
```

比如输入 `nums = [1,2,2]`，你应该输出：

```text
[ [],[1],[2],[1,2],[2,2],[1,2,2] ]
```

当然，按道理说集合不应该包含重复元素的，但既然题目这样问了，我们就忽略这个细节吧，仔细思考一下这道题怎么做才是正事。

就以 `nums = [1,2,2]` 为例，为了区别两个 `2` 是不同元素，后面我们写作 `nums = [1,2,2']`。

按照之前的思路画出子集的树形结构，显然，两条值相同的相邻树枝会产生重复：



![img](https://pic3.zhimg.com/v2-b50f8f5d55bd885c245b2d1fed9d0e1a_b.jpg)



```text
[ 
    [],
    [1],[2],[2'],
    [1,2],[1,2'],[2,2'],
    [1,2,2']
]
```

所以我们需要进行剪枝，如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历：



![img](https://pic3.zhimg.com/v2-befaa728e3c9d153fa361b49ae63f332_b.jpg)



**体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 `nums[i] == nums[i-1]`，则跳过**：

代码：

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * @lc app=leetcode.cn id=90 lang=java
 *
 * [90] 子集 II
 */

// @lc code=start
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 先排序，让相同的元素排在一起
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        ArrayList<Integer> track = new ArrayList<>();
        backtrack(res, track, 0, nums);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int start, int[] nums) {

        // 每一个节点都是一个子集
        res.add(new ArrayList<>(track));

        for (int i = start; i < nums.length; i++) {
            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            // 做选择
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(res, track, i + 1, nums);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
// @lc code=end
```

这段代码和之前标准的子集问题的代码几乎相同，就是添加了排序和剪枝的逻辑。

至于为什么要这样剪枝，结合前面的图应该也很容易理解，这样带重复元素的子集问题也解决了。

**我们说了组合问题和子集问题是等价的**，所以我们直接看一道组合的题目吧，这是力扣第 40 题「组合总和 II」：

#### 40. 组合总和II-中等

给你输入 `candidates` 和一个目标和 `target`，从 `candidates` 中找出中所有和为 `target` 的组合。

`candidates` 可能存在重复元素，且其中的每个数字最多只能使用一次。

说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 `candidates` 中所有和为 `target` 的子集。

所以这题怎么做呢？

对比子集问题的解法，只要额外用一个 `trackSum` 变量记录回溯路径上的元素和，然后将 base case 改一改即可解决这道题：

代码：

```java
/*
 * @lc app=leetcode.cn id=40 lang=java
 *
 * [40] 组合总和 II
 */

// @lc code=start
class Solution {

    // 记录track中元素总和
    int trackSum = 0;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        ArrayList<Integer> track = new ArrayList<>();
        if (candidates.length == 0) {
            return res;
        }
        // 先排序，让相同的元素靠在一起
        Arrays.sort(candidates);
        backtrack(res, track, 0, candidates, target);
        return res;
    }

    public void backtrack(List<List<Integer>> res, List<Integer> track, int start, int[] candidates, int target) {
        // 递归出口
        // 如果当前路径总和为target，则存入结果集
        if (target == trackSum) {
            res.add(new ArrayList<>(track));
            return;
        }

        // 如果超过目标和，直接结束
        if (trackSum > target) {
            return;
        }

        // 回溯算法框架
        for (int i = start; i < candidates.length; i++) {
            // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }

            // 做选择
            track.add(candidates[i]);
            // 记录元素总和
            trackSum += candidates[i];
            // 进入下一层决策树
            // 通过 start 参数控制树枝的遍历，避免产生重复的子集
            backtrack(res, track, i + 1, candidates, target);
            // 撤销选择
            track.remove(track.size() - 1);
            // 删除元素总和
            trackSum -= candidates[i];
        }
    }

}
// @lc code=end
```

排列问题的输入如果存在重复，比子集/组合问题稍微复杂一点，我们看看力扣第 47 题「全排列 II」：

#### 47. 全排列II

给你输入一个可包含重复数字的序列 `nums`，请你写一个算法，返回所有可能的全排列，函数签名如下：

```text
List<List<Integer>> permuteUnique(int[] nums)
```

比如输入 `nums = [1,2,2]`，函数返回：

```text
[ [1,2,2],[2,1,2],[2,2,1] ]
```

先看解法代码：

```java
/*
 * @lc app=leetcode.cn id=47 lang=java
 *
 * [47] 全排列 II
 */

// @lc code=start
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> track = new LinkedList<>();
    boolean[] used;

    public List<List<Integer>> permuteUnique(int[] nums) {
        // 先排序，让相同的元素靠在一起
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backtrack(nums);
        return res;
    }

    void backtrack(int[] nums) {
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            track.add(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.removeLast();
            used[i] = false;
        }
    }
}
// @lc code=end
```

你对比一下之前的标准全排列解法代码，这段解法代码只有两处不同：

1、对 `nums` 进行了排序。

2、添加了一句额外的剪枝逻辑。

类比输入包含重复元素的子集/组合问题，你大概应该理解这么做是为了防止出现重复结果。

但是注意排列问题的剪枝逻辑，和子集/组合问题的剪枝逻辑略有不同：新增了 `!used[i - 1]` 的逻辑判断。

这个地方理解起来就需要一些技巧性了，且听我慢慢到来。为了方便研究，依然把相同的元素用上标 `'` 以示区别。

假设输入为 `nums = [1,2,2']`，标准的全排列算法会得出如下答案：

```text
[
    [1,2,2'],[1,2',2],
    [2,1,2'],[2,2',1],
    [2',1,2],[2',2,1]
]
```

显然，这个结果存在重复，比如 `[1,2,2']` 和 `[1,2',2]` 应该只被算作同一个排列，但被算作了两个不同的排列。

所以现在的关键在于，如何设计剪枝逻辑，把这种重复去除掉？

**答案是，保证相同元素在排列中的相对位置保持不变**。

比如说 `nums = [1,2,2']` 这个例子，我保持排列中 `2` 一直在 `2'` 前面。

这样的话，你从上面 6 个排列中只能挑出 3 个排列符合这个条件：

```text
[ [1,2,2'],[2,1,2'],[2,2',1] ]
```

这也就是正确答案。

进一步，如果 `nums = [1,2,2',2'']`，我只要保证重复元素 `2` 的相对位置固定，比如说 `2 -> 2' -> 2''`，也可以得到无重复的全排列结果。

仔细思考，应该很容易明白其中的原理：

**标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。

那么反映到代码上，你注意看这个剪枝逻辑：

```java
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]
```

**当出现重复元素时，比如输入 `nums = [1,2,2',2'']`，`2'` 只有在 `2` 已经被使用的情况下才会被选择，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定**。

好了，这样包含重复输入的排列问题也解决了。



### 元素无重可复选

终于到了最后一种类型了：输入数组无重复元素，但每个元素可以被无限次使用。

直接看力扣第 39 题「组合总和」：

#### 39. 组合总和-中等

给你一个无重复元素的整数数组 `candidates` 和一个目标和 `target`，找出 `candidates` 中可以使数字和为目标数 `target` 的所有组合。`candidates` 中的每个数字可以无限制重复被选取。

函数签名如下：

```text
List<List<Integer>> combinationSum(int[] candidates, int target)
```

比如输入 `candidates = [1,2,3], target = 3`，算法应该返回：

```text
[ [1,1,1],[1,2],[3] ]
```

这道题说是组合问题，实际上也是子集问题：`candidates` 的哪些子集的和为 `target`？

想解决这种类型的问题，也得回到回溯树上，**我们不妨先思考思考，标准的子集/组合问题是如何保证不重复使用元素的**？

答案在于 `backtrack` 递归时输入的参数：

```text
// 回溯算法标准框架
for (int i = start; i < nums.length; i++) {
    // ...
    // 递归遍历下一层回溯树，注意参数
    backtrack(nums, i + 1, target);
    // ...
}
```

这个 `i` 从 `start` 开始，那么下一层回溯树就是从 `start + 1` 开始，从而保证 `nums[start]` 这个元素不会被重复使用：



![img](https://pic2.zhimg.com/v2-8110a7b8df79be6c6e6e42c6a6633769_b.jpg)



那么反过来，如果我想让每个元素被重复使用，我只要把 `i + 1` 改成 `i` 即可：

```text
// 回溯算法标准框架
for (int i = start; i < nums.length; i++) {
    // ...
    // 递归遍历下一层回溯树
    backtrack(nums, i, target);
    // ...
}
```

这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用：



![img](https://pic1.zhimg.com/v2-406ae565877779f74f504137b4b21afc_b.jpg)



当然，这样这棵回溯树会永远生长下去，所以我们的递归函数需要设置合适的 base case 以结束算法，即路径和大于 `target` 时就没必要再遍历下去了。

这道题的解法代码如下：

```java
/*
 * @lc app=leetcode.cn id=39 lang=java
 *
 * [39] 组合总和
 */

// @lc code=start
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    // 记录回溯的路径
    LinkedList<Integer> track = new LinkedList<>();
    // 记录 track 中的路径和
    int trackSum = 0;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target);
        return res;
    }

    // 回溯算法主函数
    void backtrack(int[] nums, int start, int target) {
        // base case，找到目标和，记录结果
        if (trackSum == target) {
            res.add(new LinkedList<>(track));
            return;
        }
        // base case，超过目标和，停止向下遍历
        if (trackSum > target) {
            return;
        }

        // 回溯算法标准框架
        for (int i = start; i < nums.length; i++) {
            // 选择 nums[i]
            trackSum += nums[i];
            track.add(nums[i]);
            // 递归遍历下一层回溯树
            // 同一元素可重复使用，注意参数
            backtrack(nums, i, target);
            // 撤销选择 nums[i]
            trackSum -= nums[i];
            track.removeLast();
        }
    }
}
// @lc code=end
```

### 最后总结

来回顾一下排列/组合/子集问题的三种形式在代码上的区别。

由于子集问题和组合问题本质上是一样的，无非就是 base case 有一些区别，所以把这两个问题放在一起看。

**形式一、元素无重不可复选，即 `nums` 中的元素都是唯一的，每个元素最多只能被使用一次**，`backtrack` 核心代码如下：

```text
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 取消选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式二、元素可重不可复选，即 `nums` 中的元素可以存在重复，每个元素最多只能被使用一次**，其关键在于排序和剪枝，`backtrack` 核心代码如下：

```text
Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 取消选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式三、元素无重可复选，即 `nums` 中的元素都是唯一的，每个元素可以被使用若干次**，只要删掉去重逻辑即可，`backtrack` 核心代码如下：

```text
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);

        backtrack(nums);
        // 取消选择
        track.removeLast();
    }
}
```

只要从树的角度思考，这些问题看似复杂多变，实则改改 base case 就能解决，这也是为什么我在 [学习算法和数据结构的框架思维](../算法思维系列/学习数据结构和算法的高效方法.md) 和 [手把手刷二叉树（纲领篇）](https://link.zhihu.com/?target=https%3A//labuladong.gitee.io/plugin-v3/%3Fqno%3D104) 中强调树类型题目重要性的原因。

如果你能够看到这里，真得给你鼓掌，相信你以后遇到各种乱七八糟的算法题，也能一眼看透它们的本质，以不变应万变。
