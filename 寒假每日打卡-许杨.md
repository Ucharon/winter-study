# 寒假学习打卡



## 1.2

### 复习题目：

#### 2. 两数相加-中等(模拟法)

**模拟法解决**

代码：

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //使用带头节点的单链表来存储答案
        ListNode head = new ListNode();
        ListNode p = head;
        
        int carry = 0;
        //当l1和l2都为null的时候退出循环
        while (!(l1 == null && l2 == null)) {
            //将两个链表中的值都给取出来
            int a = l1 != null ? l1.val : 0;
            int b = l2 != null ? l2.val : 0;
            //相加
            int sum = a + b + carry;
            //求出下一位，以及进位
            carry = sum / 10;
            sum = sum % 10;
            //新建结点
            ListNode t = new ListNode(sum);
            p.next = t;
            p = p.next;

            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
    
        //加上最后一位
        if (carry == 1) {
            p.next = new ListNode(1);
        }    

        return head.next;
    }
}
```



#### 3. 无重复字符的最长子串-中等(滑动窗口)

**滑动窗口解决**

什么是滑动窗口？

其实就是一个队列,比如例题中的 `abcabcbb`，进入这个队列（窗口）为 `abc` 满足题目要求，当再进入 `a`，队列变成了 `abca`，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

时间复杂度：O(n)

代码：

```java
class Solution {
    /**
        滑动窗口解决
     */
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        //分别记录最长窗口和当前窗口的左边界
        int max, left;
        max = left = 0;
        //记录已遍历的字符及其所在的下标
        Map<Character, Integer> map = new HashMap<>();
        
        //开始遍历
        for (int i = 0; i < s.length(); i++) {
            //如果该字母已经在哈希表中
            if (map.containsKey(s.charAt(i))) {
                //将左边界移动到该该字母的下标+1的位置，这里防止左边界回移，取left与其比较
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i - left + 1);
        }

        return max;
    }
}
```

### 新题：

#### 4. 寻找两个正序数组的中位数-困难(二分法)

**二分法解决-等价寻找第k大的数**

代码：

```java
class Solution {
    /**
        二分法解决
    
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n, m, left, right;
        n = nums1.length;
        m = nums2.length;
        left = (n + m + 1) / 2;
        right = (n + m + 2) / 2;
        return (
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) +
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)
            ) * 0.5;
    }

    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让len1的长度小于len2，这样就能保证如果有数组空了，一定是len1 
        if (len1 > len2) {
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        //如果len1为空，退出递归
        if (len1 == 0) {
            return nums2[start2 + k - 1];
        }
        //k为1
        if (k == 1) {
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(k / 2, len1) - 1;
        int j = start2 + Math.min(k / 2, len2) - 1;
        if (nums1[i] < nums2[j]) {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        } else {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
    }
}
```

#### 15. 三数之和-中等(线性枚举+二分法)

**采用线性枚举+二分法解**

该题可以转化为nums[i] + nums[j] = -nums[k]

代码：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // 该题可以转化为nums[i] + nums[j] = -nums[k]
        // 采用线性枚举+二分法解
        List<List<Integer>> res = new ArrayList<>();
        int n = nums.length;
        //先对nums进行排序
        Arrays.sort(nums);
        for (int k = 0; k < n; k++) {
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            if (nums[k] > 0) {
                break;
            }

            int i = k + 1, j = n - 1;
            while (i < j) {
                if (nums[i] + nums[j] > -nums[k]) {
                    j--;
                } else if (nums[i] + nums[j] < -nums[k]) {
                    i++;
                } else {
                    res.add(new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[k])));
                    j--;
                    i++;
                    //可能会出现连续重复的数
                    while (i < j && nums[i] == nums[i + 1]) i++;
                    while (i < j && nums[j] == nums[j - 1]) j--;
                }
            }
        }

        return res;
    }
}
```





## 1.3

今天的目标是学习巩固动态规划！

### 复习题目：

#### 5. 最长回文子串-中等(动态规划)

**经典的动态规划题**

定义状态`dp[i][j]`为i到j是否为回文串

初始化状态：每个大小为1的子串都是回文串

状态转移方程为：

​	如果`s[i] == s[j]`，且`dp[i + 1][j - 1] == 1`，则`dp[i][j] = 1`，这里有特殊情况，如果该子串大小小与等于3时候，则直接为1

​	如果`s[i] != s[j]`，则`dp[i][j] = 0`

代码：

```java
class Solution {
    /**
    动态规划求解
     */
    public String longestPalindrome(String s) {
        //定义状态
        int n = s.length();
        int[][] dp = new int[n][n];
        //初始化状态
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        int left = 0;
        int maxLen = 1;
        //状态转移
        //枚举子串长度
        for (int l = 2; l <= n; l++) {
            //遍历字符串
            for (int i = 0; i < n; i++) {
                //确定右边界
                int j = i + l - 1;
                //右边界越界情况
                if (j >= n) {
                    break;
                }

                if (s.charAt(i) != s.charAt(j)) {
                    dp[i][j] = 0;
                } else {
                    if (j - i <= 2) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                //如果当前dp[i][j]为1，且长度大于目前最大长度，则记录当前长度以及下标
                if (dp[i][j] == 1 && l > maxLen) {
                    maxLen = l;
                    left = i;
                }
            }
        }
        return s.substring(left, left + maxLen);
    }
}
```

#### 198. 打家劫舍-中等(动态规划)

**经典动态规划题**

- 定义状态，`dp[i]`表示已i为结尾能打劫到最大的钱的大小

- 初始化状态，`dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`

- 写出状态转移方程，`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int rob(int[] nums) {
        int n = nums.length;
        //定义状态
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        if (n == 1) {
            return dp[0];   
        }
        dp[1] = Math.max(nums[0], nums[1]);

        //状态转移方程
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
```







### 新题：

#### 10. 正则表达式匹配-困难(动态规划)

**二维动态规划**

1. 定义状态

    `dp[i][j]`表示当字符串长度分别为i、j时，s与p是否匹配

2. 写出状态转移方程

    1. 当`p[j] = '.'或s[i]`时，`dp[i][j] = dp[i - 1][j - 1]`
    2. 当`p[j] = '*'`时
        1. `p[j - 1] != s[i]`，表示不匹配时候，`dp[i][j] = dp[i][j - 2]`
        2. `p[j - 1] != s[i]`，表示匹配的时候，接下来分**3种情况**讨论
            1. 当`*`匹配0个，`dp[i][j] = dp[i][j - 2]`
            2. 当`*`匹配1个，`dp[i][j] = dp[i][j - 1]`
            3. 当`*`匹配2个或更多，`dp[i][j] = dp[i - 1][j]`

代码如下：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        //空字符串处理
        if (s == null || p == null) {
            return true;
        }

        int n, m;
        n = s.length();
        m = p.length();
        //定义状态
        boolean[][] dp = new boolean[n + 1][m + 1];
        //初始化状态
        dp[0][0] = true;
        for (int i = 2; i <= m; i++) {
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = dp[0][i - 2];
            }
        }

        //状态转移
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                //当j不为*
                if (p.charAt(j - 1) != '*') {
                    if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    //第j-1个字符不匹配
                    if (p.charAt(j - 2) != s.charAt(i - 1) && p.charAt(j - 2) != '.') {
                        dp[i][j] = dp[i][j - 2];
                    } else {
                        dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j];
                    }
                }
            }
        }

        return dp[n][m];
    }
  
}
```

#### 19. 删除链表的倒数第 N 个结点-中等(双指针)

**双指针解决问题**

代码：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode quick, slow;
        //先定义一个指针，让他移动n次
        quick = head;
        for (int i = 0; i < n; i++) {
            quick = quick.next;
        }
        if (quick == null) {
            //说明删除的是头节点
            return head.next;
        }
        //再定义慢指针，该指针从head出发
        slow = head;
        while (quick.next != null) {
            slow = slow.next;
            quick = quick.next;
        }
        //删除slow的下一个结点
        slow.next = slow.next.next;

        return head;
    }
}
```

#### 740. 删除并获得点数-中等(动态规划)

这题也是动态规划，和上面的打家劫舍有异曲同工之妙

代码：

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = 0;
        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }
        int[] sum = new int[maxVal + 1];
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }

    public int rob(int[] nums) {
        int size = nums.length;
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```





## 1.4

今天也学几个动态规划题目，顺便预热下回溯算法

### 复习题目：

#### 53. 最大子数组和-中等(动态规划)

直接看代码，**简单动态规划题**

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int n = nums.length;
        //定义状态
        //dp[i]表示以i为结尾的子数组的最大和
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        int res = dp[0];

        //状态转移
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); 
            if (res < dp[i]) {
                res = dp[i];
            }
        }

        return res;
    }
}
```



#### 46. 全排列-中等(回溯)

回溯算法的套路：[回溯算法套路详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/93530380?utm_campaign=&utm_medium=social&utm_oi=963759403787276288&utm_psn=1594052365698420736&utm_source=qq)

##### 回溯算法的框架：

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

代码：

```java
class Solution {
    /**
    符合回溯算法框架
     */

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        dfs(res, nums, new ArrayList<>());
        return res;
    }

    public void dfs(List<List<Integer>> res, int[] nums, List<Integer> track) {
        //递归出口
        int n = nums.length;
        if (track.size() == n) {
            res.add(new ArrayList(track));
            return;
        }

        for (int i = 0; i < n; i++) {
            //排除不合法情况
            if (track.contains(nums[i])) {
                continue;
            }
            //做选择
            track.add(nums[i]);
            //进入下一层决策树
            dfs(res, nums, track);
            //撤销选择
            track.remove(track.size() - 1);
        }

    }
}
```

![截屏2023-01-04 19.29.58](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2019.29.58.png)

### 新题：

#### 322. 零钱兑换-中等(动态规划)

**动态规划题**

1. 定义状态

    `dp[i]`表示凑出i块钱最少需要多少硬币

2. 写出状态转移方程

    对于`coin[j]`这个硬币，这里有两种情况

    - 选取该硬币

        `dp[i] = dp[i-coins[j] ] + 1`，不过这里还需要注意，在选的时候，还得考虑 `coins[j]` 是否比 i 大，如果比 i 大的话，显然是不能选的。

    - 不选取该硬币

        `dp[i] = dp[i]`

3. 初始值就比较简单了，当 i = 0 时，显然有 dp[0] = 0。

    不过这里需要注意的是，我们还需要给所有 dp[i] 都赋予一个初始值，否则在递推公式 dp[i] = min(dp[i], dp[i – coins[j]] + 1) 的过程中，dp[i] 有可能会被初始值覆盖，所以我们得给 dp[i] 赋上一个**尽量大**的初始值，可以赋值为 amout + 1。

    详情看代码吧，有些细节需要在代码，才更好说明

代码：

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //定义状态
        //dp[i]表示凑出i块钱最少需要多少硬币
        int[] dp = new int[amount + 1];
        //初始化状态 
        // 这里我们还得给dp[i]赋予一个尽量大的初始值
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;

        //写出状态转移方程
        for (int i = 1; i <= amount; i++) {
            //计算dp[i]所需最少硬币的数量
            for (int j = 0; j < coins.length; j++) {
                //总金额一定大于硬币大小
                if (i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }

        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

![截屏2023-01-04 18.29.13](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2018.29.13.png)



#### 20. 有效的括号-简单(栈)

**考察栈的概念**

代码：

```java
class Solution {
    /**
    考察栈的基本概念--先进后出
     */
    public boolean isValid(String s) {
        //新建一个哈希表
        Map<Character, Character> map = new HashMap<>(){{
            put('(', ')'); 
            put('{', '}');
            put('[', ']');
            put('?', '?');
        }};

        if(s.length() > 0 && !map.containsKey(s.charAt(0))) {
            return false;
        }

        LinkedList<Character> stack = new LinkedList<Character>() {{
             add('?');
        }};

        for(Character c : s.toCharArray()){
            if(map.containsKey(c)) { 
                stack.addLast(c);
            } else if(map.get(stack.removeLast()) != c) {
                return false;
            }
        }
        return stack.size() == 1;
    }
}
```

![截屏2023-01-04 18.46.49](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2018.46.49.png)

#### 22. 括号生成-中等(回溯)

**经典回溯算法**

代码：

```java
class Solution {
    /**
    回溯解法
     */
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();
        dfs(n, res, 0, 0, "");
        return res;
    }

    public void dfs(int n, List<String> res, int left, int right, String str) {
        //递归出口
        if (left < right) {
            return;
        }
        if (left == right && right == n) {
            res.add(str);
            return;
        }

        if (left < n) {
            //加左括号
            dfs(n, res, left + 1, right, str + "(");
        }
        if (right < left) {
            //加右括号
            dfs(n, res, left, right + 1, str + ")");
        }
    }
}
```

![截屏2023-01-04 19.14.07](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-01-04%2019.14.07.png)
