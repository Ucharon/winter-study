# 寒假学习打卡



## 1.2

### 复习题目：

#### 2. 两数相加-中等

**模拟法解决**

代码：

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //使用带头节点的单链表来存储答案
        ListNode head = new ListNode();
        ListNode p = head;
        
        int carry = 0;
        //当l1和l2都为null的时候退出循环
        while (!(l1 == null && l2 == null)) {
            //将两个链表中的值都给取出来
            int a = l1 != null ? l1.val : 0;
            int b = l2 != null ? l2.val : 0;
            //相加
            int sum = a + b + carry;
            //求出下一位，以及进位
            carry = sum / 10;
            sum = sum % 10;
            //新建结点
            ListNode t = new ListNode(sum);
            p.next = t;
            p = p.next;

            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
    
        //加上最后一位
        if (carry == 1) {
            p.next = new ListNode(1);
        }    

        return head.next;
    }
}
```



#### 3. 无重复字符的最长子串-中等

**滑动窗口解决**

什么是滑动窗口？

其实就是一个队列,比如例题中的 `abcabcbb`，进入这个队列（窗口）为 `abc` 满足题目要求，当再进入 `a`，队列变成了 `abca`，这时候不满足要求。所以，我们要移动这个队列！

如何移动？

我们只要把队列的左边的元素移出就行了，直到满足题目要求！

一直维持这样的队列，找出队列出现最长的长度时候，求出解！

时间复杂度：O(n)

代码：

```java
class Solution {
    /**
        滑动窗口解决
     */
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        //分别记录最长窗口和当前窗口的左边界
        int max, left;
        max = left = 0;
        //记录已遍历的字符及其所在的下标
        Map<Character, Integer> map = new HashMap<>();
        
        //开始遍历
        for (int i = 0; i < s.length(); i++) {
            //如果该字母已经在哈希表中
            if (map.containsKey(s.charAt(i))) {
                //将左边界移动到该该字母的下标+1的位置，这里防止左边界回移，取left与其比较
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }
            map.put(s.charAt(i), i);
            max = Math.max(max, i - left + 1);
        }

        return max;
    }
}
```

### 新题：

#### 4. 寻找两个正序数组的中位数-困难

**二分法解决-等价寻找第k大的数**

代码：

```java
class Solution {
    /**
        二分法解决
    
     */
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n, m, left, right;
        n = nums1.length;
        m = nums2.length;
        left = (n + m + 1) / 2;
        right = (n + m + 2) / 2;
        return (
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) +
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)
            ) * 0.5;
    }

    private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
        int len1 = end1 - start1 + 1;
        int len2 = end2 - start2 + 1;
        //让len1的长度小于len2，这样就能保证如果有数组空了，一定是len1 
        if (len1 > len2) {
            return getKth(nums2, start2, end2, nums1, start1, end1, k);
        }
        //如果len1为空，退出递归
        if (len1 == 0) {
            return nums2[start2 + k - 1];
        }
        //k为1
        if (k == 1) {
            return Math.min(nums1[start1], nums2[start2]);
        }

        int i = start1 + Math.min(k / 2, len1) - 1;
        int j = start2 + Math.min(k / 2, len2) - 1;
        if (nums1[i] < nums2[j]) {
            return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
        } else {
            return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
        }
    }
}
```

#### 15. 三数之和-中等

**采用线性枚举+二分法解**

该题可以转化为nums[i] + nums[j] = -nums[k]

代码：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        // 该题可以转化为nums[i] + nums[j] = -nums[k]
        // 采用线性枚举+二分法解
        List<List<Integer>> res = new ArrayList<>();
        int n = nums.length;
        //先对nums进行排序
        Arrays.sort(nums);
        for (int k = 0; k < n; k++) {
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            if (nums[k] > 0) {
                break;
            }

            int i = k + 1, j = n - 1;
            while (i < j) {
                if (nums[i] + nums[j] > -nums[k]) {
                    j--;
                } else if (nums[i] + nums[j] < -nums[k]) {
                    i++;
                } else {
                    res.add(new ArrayList<>(Arrays.asList(nums[i], nums[j], nums[k])));
                    j--;
                    i++;
                    //可能会出现连续重复的数
                    while (i < j && nums[i] == nums[i + 1]) i++;
                    while (i < j && nums[j] == nums[j - 1]) j--;
                }
            }
        }

        return res;
    }
}
```





## 1.3

今天的目标是学习巩固动态规划！

### 复习题目：

#### 5. 最长回文子串-中等

**经典的动态规划题**

定义状态`dp[i][j]`为i到j是否为回文串

初始化状态：每个大小为1的子串都是回文串

状态转移方程为：

​	如果`s[i] == s[j]`，且`dp[i + 1][j - 1] == 1`，则`dp[i][j] = 1`，这里有特殊情况，如果该子串大小小与等于3时候，则直接为1

​	如果`s[i] != s[j]`，则`dp[i][j] = 0`

代码：

```java
class Solution {
    /**
    动态规划求解
     */
    public String longestPalindrome(String s) {
        //定义状态
        int n = s.length();
        int[][] dp = new int[n][n];
        //初始化状态
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        int left = 0;
        int maxLen = 1;
        //状态转移
        //枚举子串长度
        for (int l = 2; l <= n; l++) {
            //遍历字符串
            for (int i = 0; i < n; i++) {
                //确定右边界
                int j = i + l - 1;
                //右边界越界情况
                if (j >= n) {
                    break;
                }

                if (s.charAt(i) != s.charAt(j)) {
                    dp[i][j] = 0;
                } else {
                    if (j - i <= 2) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                //如果当前dp[i][j]为1，且长度大于目前最大长度，则记录当前长度以及下标
                if (dp[i][j] == 1 && l > maxLen) {
                    maxLen = l;
                    left = i;
                }
            }
        }
        return s.substring(left, left + maxLen);
    }
}
```

#### 198. 打家劫舍

**经典动态规划题**

- 定义状态，`dp[i]`表示已i为结尾能打劫到最大的钱的大小

- 初始化状态，`dp[0] = nums[0], dp[1] = max(nums[0], nums[1])`

- 写出状态转移方程，`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`

代码：

```java
class Solution {
    /**
    经典动态规划题
     */
    public int rob(int[] nums) {
        int n = nums.length;
        //定义状态
        int[] dp = new int[n];
        //初始化状态
        dp[0] = nums[0];
        if (n == 1) {
            return dp[0];   
        }
        dp[1] = Math.max(nums[0], nums[1]);

        //状态转移方程
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
```







### 新题：

#### 10. 正则表达式匹配-困难

**二维动态规划**

1. 定义状态

    `dp[i][j]`表示当字符串长度分别为i、j时，s与p是否匹配

2. 写出状态转移方程

    1. 当`p[j] = '.'或s[i]`时，`dp[i][j] = dp[i - 1][j - 1]`
    2. 当`p[j] = '*'`时
        1. `p[j - 1] != s[i]`，表示不匹配时候，`dp[i][j] = dp[i][j - 2]`
        2. `p[j - 1] != s[i]`，表示匹配的时候，接下来分**3种情况**讨论
            1. 当`*`匹配0个，`dp[i][j] = dp[i][j - 2]`
            2. 当`*`匹配1个，`dp[i][j] = dp[i][j - 1]`
            3. 当`*`匹配2个或更多，`dp[i][j] = dp[i - 1][j]`

代码如下：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        //空字符串处理
        if (s == null || p == null) {
            return true;
        }

        int n, m;
        n = s.length();
        m = p.length();
        //定义状态
        boolean[][] dp = new boolean[n + 1][m + 1];
        //初始化状态
        dp[0][0] = true;
        for (int i = 2; i <= m; i++) {
            if (p.charAt(i - 1) == '*') {
                dp[0][i] = dp[0][i - 2];
            }
        }

        //状态转移
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                //当j不为*
                if (p.charAt(j - 1) != '*') {
                    if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                        dp[i][j] = dp[i - 1][j - 1];
                    }
                } else {
                    //第j-1个字符不匹配
                    if (p.charAt(j - 2) != s.charAt(i - 1) && p.charAt(j - 2) != '.') {
                        dp[i][j] = dp[i][j - 2];
                    } else {
                        dp[i][j] = dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j];
                    }
                }
            }
        }

        return dp[n][m];
    }
  
}
```

#### 19. 删除链表的倒数第 N 个结点-中等

**双指针解决问题**

代码：

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode quick, slow;
        //先定义一个指针，让他移动n次
        quick = head;
        for (int i = 0; i < n; i++) {
            quick = quick.next;
        }
        if (quick == null) {
            //说明删除的是头节点
            return head.next;
        }
        //再定义慢指针，该指针从head出发
        slow = head;
        while (quick.next != null) {
            slow = slow.next;
            quick = quick.next;
        }
        //删除slow的下一个结点
        slow.next = slow.next.next;

        return head;
    }
}
```

#### 740. 删除并获得点数

这题也是动态规划，和上面的打家劫舍有异曲同工之妙

代码：

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int maxVal = 0;
        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }
        int[] sum = new int[maxVal + 1];
        for (int val : nums) {
            sum[val] += val;
        }
        return rob(sum);
    }

    public int rob(int[] nums) {
        int size = nums.length;
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}
```



