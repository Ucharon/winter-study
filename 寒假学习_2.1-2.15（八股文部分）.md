---

---

# 寒假学习_2.1-2.15（八股文部分）

## 2.1

今天复习几个排序算法

### 1. 冒泡排序

#### 代码实现

最终改进的冒泡排序代码

```java
public void bubbleSort(int[] a) {
    int n = a.length - 1;
    for (;;) {
        int last = 0;	//表示最后一次交换时，索引的位置
        for (int j = 0; j < n; j++) {
            if (a[j] > a[j + 1]) {
                swap(a, j, j + 1);
                last = j;
            }
        }
        n = last;
        //n==0表示本轮没有发生一次交换，表示该数组本来就有序，排序结束
        if (n == 0) {
            break;
        }
    }
}

public void swap(int[] a, int x, int y) {
    int t = a[x];
    a[x] = a[y];
    a[y] = t;
}
```

#### 文字描述(以升序为例)：

1. 依次比较数组中相邻两个元素大小，若 `a[j] > a[j + 1]`，则交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后
2. 重复以上步骤，直到整个数组有序

#### 优化方式：

每轮冒泡时，最后一次交换 索引可以作为下一轮冒泡的比较次数， 如果这个值为零，表示整个数组有序， 直接退出外层循环即可



### 2. 选择排序

#### 代码实现

```java
public void selectionSort(int[] a) {
    for (int i = 0; i < a.length - 1; i++) {
        // i 代表每轮选择到的最小的元素所要交换到的索引
        int s = i;	//代表找到的最小元素的索引值
        
        for (int j = i + 1; j < a.length; j++) {
            if (a[s] > a[j]) {
                s = j;
            }
        }
        
        if (s != i) {
            swap(a, s, i);
        }
    }
}
```



#### 文字描述（以升序为例）

1. 将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素，放入排序子集
2. 重复以上步骤，直到整个数组有序

#### 优化方式

为减少交换次数，每一轮可以先找最小的索引， 在每轮最后再交换元素

#### 与冒泡排序比较

1. 二者平均时间复杂度都是`O(n2) `
2. 选择排序一般要快于冒泡，因为其交换次数少 
3. 但如果集合有序度高，冒泡优于选择 
4. 冒泡属于稳定排序算法，而选择属于不稳定排序



### 3. 插入排序

#### 代码实现

```java
public void insertSort(int[] a) {
    // i代表带插入元素的索引
    for (int i = 1; i < a.length; i++) {
        int t = a[i];	//记录带插入元素的值
        int j = i - 1;	//j表示已排序部分的最后一位数的索引
        
        while (j >= 0) {
            if (t < a[j]) {
                a[j + 1] = a[j];
            } else {
                break;	//退出循环，减少比较次数
            }
            j--;
        }
        a[j + 1] = t;
    }
}
```

#### 文字描述（以升序为例） 

1. 将数组分为两个区域，排序区域和未排序区域，每一轮从未排序区域中取出第一个元素，插入到排序区域（需保证顺序) 
2. 重复以上步骤，直到整个数组有序 

#### 优化方式

1. 待插入元素进行比较时，遇到比自己小的元素，就代表找到了插入位置，无需进行后续比铰
2. 插入时可以直接移动元素，而不是交换元素

#### 与选择排序比较 

1. 二者平均时间复杂度都是`O(n2)`
2. 大部分情况下，插入都略优于选择 
3. 有序集合插入的时间复杂度为`O(n)`
4. 插入属于稳定排序算法，而选择属于不稳定排序



### 4. 希尔排序

改进的插入排序（优化：原数组的一个元素距离正确位置很远的情况）
先让间隔 `h` 的元素有序，在使得间隔为 `h / 2`，一直缩小，一直到 `h = 1`（此时数组有序）。

时间复杂度介于`nlogn`和`n^2`之间，空间复杂度1

具体的情况不做演示，了解即可



### 5. 快速排序

#### 1. 单边循环快排（lmuto分区实现方案）

1. 选择最右元素作为基准点元素

2. j指针负责找到比基准点小的元素，一旦找到则与ⅰ进行交换

3. ⅰ指针维护小于基准点元素的边界，也是每次交换的目标索引 

4. 最后基准点与ⅰ交换，ⅰ即为分区位置



#### 2. 双边循环快排（并不完全等价于hoare霍尔分区方案）

1. 选择最左元素作为基准点元素
2. j指针负责从右向左找比基准点小的元素，ⅰ指针负责从左向右 找比基准点大的元素，一旦找到二者交换，直至i,j相交 
3. 最后基准点与ⅰ（此时i与j相等）交换，ⅰ即为分区位置

